// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_networks

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func NetworksDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"networks": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"auto_scale_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable auto scaling on the Network.",
							MarkdownDescription: "Whether or not to enable auto scaling on the Network.",
						},
						"dhcp_boot_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Toggles on the DHCP boot options. Will be set to true if you have `dhcpd_boot_filename`, and `dhcpd_boot_server` set.",
							MarkdownDescription: "Toggles on the DHCP boot options. Will be set to true if you have `dhcpd_boot_filename`, and `dhcpd_boot_server` set.",
						},
						"dhcp_boot_filename": schema.StringAttribute{
							Computed:            true,
							Description:         "The file to PXE boot from on the `dhcpd_boot_server`.",
							MarkdownDescription: "The file to PXE boot from on the `dhcpd_boot_server`.",
						},
						"dhcp_boot_server": schema.StringAttribute{
							Computed:            true,
							Description:         "IPv4 address of a TFTP server to network boot from.",
							MarkdownDescription: "IPv4 address of a TFTP server to network boot from.",
						},
						"dhcp_conflict_checking": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable DHCPd Conflict Checking.",
							MarkdownDescription: "Whether or not to enable DHCPd Conflict Checking.",
						},
						"dhcp_dns": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "IPv4 addresses for the DNS server to be returned from the DHCP server.",
							MarkdownDescription: "IPv4 addresses for the DNS server to be returned from the DHCP server.",
						},
						"dhcp_dns_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable DNS for DHCP.",
							MarkdownDescription: "Whether or not to enable DNS for DHCP.",
						},
						"dhcp_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether DHCP is enabled or not on the Network.",
							MarkdownDescription: "Whether DHCP is enabled or not on the Network.",
						},
						"dhcp_gateway_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable DHCPd Gateway.",
							MarkdownDescription: "Whether or not to enable DHCPd Gateway.",
						},
						"dhcp_guard_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable DHCP Guard.",
							MarkdownDescription: "Whether or not to enable DHCP Guard.",
						},
						"dhcp_lease_time": schema.Int64Attribute{
							Computed:            true,
							Description:         "Lease time for DHCP addresses.",
							MarkdownDescription: "Lease time for DHCP addresses.",
						},
						"dhcp_ntp_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable NTP for DHCPd.",
							MarkdownDescription: "Whether or not to enable NTP for DHCPd.",
						},
						"dhcp_relay_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable a DHCP Relay server.",
							MarkdownDescription: "Whether or not to enable a DHCP Relay server.",
						},
						"dhcp_start": schema.StringAttribute{
							Computed:            true,
							Description:         "The IPv4 address where the DHCP range of addresses start.",
							MarkdownDescription: "The IPv4 address where the DHCP range of addresses start.",
						},
						"dhcp_stop": schema.StringAttribute{
							Computed:            true,
							Description:         "The IPv4 address where the DHCP range of addresses stop.",
							MarkdownDescription: "The IPv4 address where the DHCP range of addresses stop.",
						},
						"dhcp_tftp_server": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the TFTP server for DHCPd.",
							MarkdownDescription: "Specifies the TFTP server for DHCPd.",
						},
						"dhcp_time_offset_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable Time Offset for DHCPd.",
							MarkdownDescription: "Whether or not to enable Time Offset for DHCPd.",
						},
						"dhcp_unifi_controller": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the Unifi Controller for DHCPd.",
							MarkdownDescription: "Specifies the Unifi Controller for DHCPd.",
						},
						"dhcp_v6_allow_slaac": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to allow slaac with DHCP v6.",
							MarkdownDescription: "Whether or not to allow slaac with DHCP v6.",
						},
						"dhcp_v6_dns": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "Specifies the IPv6 addresses for the DNS server to be returned from the DHCP server. Used if `dhcp_v6_dns_auto` is set to `false`.",
							MarkdownDescription: "Specifies the IPv6 addresses for the DNS server to be returned from the DHCP server. Used if `dhcp_v6_dns_auto` is set to `false`.",
						},
						"dhcp_v6_dns_auto": schema.BoolAttribute{
							Computed:            true,
							Description:         "Specifies DNS source to propagate. If set `false` the entries in `dhcp_v6_dns` are used, the upstream entries otherwise.",
							MarkdownDescription: "Specifies DNS source to propagate. If set `false` the entries in `dhcp_v6_dns` are used, the upstream entries otherwise.",
						},
						"dhcp_v6_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Enable stateful DHCPv6 for static configuration.",
							MarkdownDescription: "Enable stateful DHCPv6 for static configuration.",
						},
						"dhcp_v6_lease_time": schema.Int64Attribute{
							Computed:            true,
							Description:         "Specifies the lease time for DHCPv6 addresses.",
							MarkdownDescription: "Specifies the lease time for DHCPv6 addresses.",
						},
						"dhcp_v6_start": schema.StringAttribute{
							Computed:            true,
							Description:         "Start address of the DHCPv6 range. Used in static DHCPv6 configuration.",
							MarkdownDescription: "Start address of the DHCPv6 range. Used in static DHCPv6 configuration.",
						},
						"dhcp_v6_stop": schema.StringAttribute{
							Computed:            true,
							Description:         "End address of the DHCPv6 range. Used in static DHCPv6 configuration.",
							MarkdownDescription: "End address of the DHCPv6 range. Used in static DHCPv6 configuration.",
						},
						"dhcp_wins_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "TODO: Figure out what this is.",
							MarkdownDescription: "TODO: Figure out what this is.",
						},
						"dhcp_wpad_url": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the WPAd URL for DHCPd.",
							MarkdownDescription: "Specifies the WPAd URL for DHCPd.",
						},
						"domain_name": schema.StringAttribute{
							Computed:            true,
							Description:         "The domain name of the network.",
							MarkdownDescription: "The domain name of the network.",
						},
						"enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable the Network.",
							MarkdownDescription: "Whether or not to enable the Network.",
						},
						"gateway_type": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the Gateway type.",
							MarkdownDescription: "Specifies the Gateway type.",
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "The ID of the Network.",
							MarkdownDescription: "The ID of the Network.",
						},
						"igmp_snooping": schema.BoolAttribute{
							Computed:            true,
							Description:         "Specifies whether IGMP snooping is enabled or not.",
							MarkdownDescription: "Specifies whether IGMP snooping is enabled or not.",
						},
						"internet_access_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Specifies whether internet access is enabled for the Network or not.",
							MarkdownDescription: "Specifies whether internet access is enabled for the Network or not.",
						},
						"ipv6_client_address_assignment": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the client address assignment for IPv6",
							MarkdownDescription: "Specifies the client address assignment for IPv6",
						},
						"ipv6_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable IPv6.",
							MarkdownDescription: "Whether or not to enable IPv6.",
						},
						"ipv6_interface_type": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies which type of IPv6 connection to use. Must be one of either `static`, `pd`, or `none`.",
							MarkdownDescription: "Specifies which type of IPv6 connection to use. Must be one of either `static`, `pd`, or `none`.",
						},
						"ipv6_pd_auto_prefixid_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable IPv6 Auto Prefix ID.",
							MarkdownDescription: "Whether or not to enable IPv6 Auto Prefix ID.",
						},
						"ipv6_pd_interface": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies which WAN interface to use for IPv6 PD. Must be one of either `wan` or `wan2`.",
							MarkdownDescription: "Specifies which WAN interface to use for IPv6 PD. Must be one of either `wan` or `wan2`.",
						},
						"ipv6_pd_prefixid": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the IPv6 Prefix ID.",
							MarkdownDescription: "Specifies the IPv6 Prefix ID.",
						},
						"ipv6_pd_start": schema.StringAttribute{
							Computed:            true,
							Description:         "Start address of the DHCPv6 range. Used if `ipv6_interface_type` is set to `pd`.",
							MarkdownDescription: "Start address of the DHCPv6 range. Used if `ipv6_interface_type` is set to `pd`.",
						},
						"ipv6_pd_stop": schema.StringAttribute{
							Computed:            true,
							Description:         "End address of the DHCPv6 range. Used if `ipv6_interface_type` is set to `pd`.",
							MarkdownDescription: "End address of the DHCPv6 range. Used if `ipv6_interface_type` is set to `pd`.",
						},
						"ipv6_ra_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Specifies whether to enable router advertisements or not.",
							MarkdownDescription: "Specifies whether to enable router advertisements or not.",
						},
						"ipv6_ra_preferred_lifetime": schema.Int64Attribute{
							Computed:            true,
							Description:         "Lifetime in which the address can be used. Address becomes deprecated afterwards. Must be lower than or equal to `ipv6_ra_valid_lifetime`.",
							MarkdownDescription: "Lifetime in which the address can be used. Address becomes deprecated afterwards. Must be lower than or equal to `ipv6_ra_valid_lifetime`.",
						},
						"ipv6_ra_priority": schema.StringAttribute{
							Computed:            true,
							Description:         "IPv6 router advertisement priority. Must be one of either `high`, `medium`, or `low`.",
							MarkdownDescription: "IPv6 router advertisement priority. Must be one of either `high`, `medium`, or `low`.",
						},
						"ipv6_ra_valid_lifetime": schema.Int64Attribute{
							Computed:            true,
							Description:         "Total lifetime in which the address can be used. Must be equal to or greater than `ipv6_ra_preferred_lifetime`.",
							MarkdownDescription: "Total lifetime in which the address can be used. Must be equal to or greater than `ipv6_ra_preferred_lifetime`.",
						},
						"ipv6_setting_preference": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the setting preference for IPv6.",
							MarkdownDescription: "Specifies the setting preference for IPv6.",
						},
						"ipv6_static_subnet": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the static IPv6 subnet (when `ipv6_interface_type` is `static`).",
							MarkdownDescription: "Specifies the static IPv6 subnet (when `ipv6_interface_type` is `static`).",
						},
						"lte_lan_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable LTE LAN.",
							MarkdownDescription: "Whether or not to enable LTE LAN.",
						},
						"multicast_dns_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Specifies whether Multicast DNS (mDNS) is enabled or not on the Network (Controller >=v7).",
							MarkdownDescription: "Specifies whether Multicast DNS (mDNS) is enabled or not on the Network (Controller >=v7).",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "The name of the Network.",
							MarkdownDescription: "The name of the Network.",
						},
						"nat_outbound_ip_addresses": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ip_address": schema.StringAttribute{
										Computed:            true,
										Description:         "Specifies a single IP address to use for outbound NAT. Used when `mode` is set to `ip_address`.",
										MarkdownDescription: "Specifies a single IP address to use for outbound NAT. Used when `mode` is set to `ip_address`.",
									},
									"ip_address_pool": schema.ListAttribute{
										ElementType:         types.StringType,
										Computed:            true,
										Description:         "Specifies a list of IP addresses to use for outbound NAT. Used when `mode` is set to `ip_address_pool`.",
										MarkdownDescription: "Specifies a list of IP addresses to use for outbound NAT. Used when `mode` is set to `ip_address_pool`.",
									},
									"mode": schema.StringAttribute{
										Computed:            true,
										Description:         "Specifies the mode for outbound NAT. Can be one of `all`, `ip_address`, or `ip_address_pool`.",
										MarkdownDescription: "Specifies the mode for outbound NAT. Can be one of `all`, `ip_address`, or `ip_address_pool`.",
									},
									"wan_network_group": schema.StringAttribute{
										Computed:            true,
										Description:         "Specifies the WAN network group that the outbound NAT is associated with. Can be one of `WAN`, `WAN2`.",
										MarkdownDescription: "Specifies the WAN network group that the outbound NAT is associated with. Can be one of `WAN`, `WAN2`.",
									},
								},
								CustomType: NatOutboundIpAddressesType{
									ObjectType: types.ObjectType{
										AttrTypes: NatOutboundIpAddressesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Specifies the outbound IP address pool for NAT.",
							MarkdownDescription: "Specifies the outbound IP address pool for NAT.",
						},
						"network_group": schema.StringAttribute{
							Computed:            true,
							Description:         "The group of the Network.",
							MarkdownDescription: "The group of the Network.",
						},
						"network_isolation_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Specifies whether network isolation is enabled for the Network.",
							MarkdownDescription: "Specifies whether network isolation is enabled for the Network.",
						},
						"purpose": schema.StringAttribute{
							Computed:            true,
							Description:         "The purpose of the Network. One of `corporate`, `guest`, `wan`, or `vlan-only`.",
							MarkdownDescription: "The purpose of the Network. One of `corporate`, `guest`, `wan`, or `vlan-only`.",
						},
						"setting_preference": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the setting preference for the Network.",
							MarkdownDescription: "Specifies the setting preference for the Network.",
						},
						"site_id": schema.StringAttribute{
							Computed:            true,
							Description:         "The ID of the site the Network is associated with.",
							MarkdownDescription: "The ID of the site the Network is associated with.",
						},
						"subnet": schema.StringAttribute{
							Computed:            true,
							Description:         "The subnet of the Network (CIDR address).",
							MarkdownDescription: "The subnet of the Network (CIDR address).",
						},
						"upnp_lan_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable UPnP LAN.",
							MarkdownDescription: "Whether or not to enable UPnP LAN.",
						},
						"vlan_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether or not to enable VLAN.",
							MarkdownDescription: "Whether or not to enable VLAN.",
						},
						"vlan_id": schema.Int64Attribute{
							Computed:            true,
							Description:         "The VLAN ID of the Network.",
							MarkdownDescription: "The VLAN ID of the Network.",
						},
						"wan_dhcp_v6_pd_size": schema.Int64Attribute{
							Computed:            true,
							Description:         "Specifies the IPv6 prefix size to request from ISP. Must be a number between 48 and 64.",
							MarkdownDescription: "Specifies the IPv6 prefix size to request from ISP. Must be a number between 48 and 64.",
						},
						"wan_dns": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "DNS servers IPs of the WAN.",
							MarkdownDescription: "DNS servers IPs of the WAN.",
						},
						"wan_egress_qos": schema.Int64Attribute{
							Computed:            true,
							Description:         "Specifies the WAN egress quality of service.",
							MarkdownDescription: "Specifies the WAN egress quality of service.",
						},
						"wan_gateway": schema.StringAttribute{
							Computed:            true,
							Description:         "The IPv4 gateway of the WAN.",
							MarkdownDescription: "The IPv4 gateway of the WAN.",
						},
						"wan_gateway_v6": schema.StringAttribute{
							Computed:            true,
							Description:         "The IPv6 gateway of the WAN.",
							MarkdownDescription: "The IPv6 gateway of the WAN.",
						},
						"wan_ip": schema.StringAttribute{
							Computed:            true,
							Description:         "The IPv4 address of the WAN.",
							MarkdownDescription: "The IPv4 address of the WAN.",
						},
						"wan_ipv6": schema.StringAttribute{
							Computed:            true,
							Description:         "The IPv6 address of the WAN.",
							MarkdownDescription: "The IPv6 address of the WAN.",
						},
						"wan_netmask": schema.StringAttribute{
							Computed:            true,
							Description:         "The IPv4 netmask of the WAN.",
							MarkdownDescription: "The IPv4 netmask of the WAN.",
						},
						"wan_network_group": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the WAN network group. One of either `WAN`, `WAN2`, or `WAN_LTE_FAILOVER`.",
							MarkdownDescription: "Specifies the WAN network group. One of either `WAN`, `WAN2`, or `WAN_LTE_FAILOVER`.",
						},
						"wan_password": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the IPv4 WAN password.",
							MarkdownDescription: "Specifies the IPv4 WAN password.",
						},
						"wan_prefixlen": schema.Int64Attribute{
							Computed:            true,
							Description:         "The IPv6 prefix length of the WAN. Must be a number between 1 and 128.",
							MarkdownDescription: "The IPv6 prefix length of the WAN. Must be a number between 1 and 128.",
						},
						"wan_type": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the IPv4 WAN connection type. One of either `disabled`, `static`, `dhcp`, or `pppoe`.",
							MarkdownDescription: "Specifies the IPv4 WAN connection type. One of either `disabled`, `static`, `dhcp`, or `pppoe`.",
						},
						"wan_type_v6": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the IPv6 WAN connection type. Must be one of either `disabled`, `static`, or `dhcpv6`.",
							MarkdownDescription: "Specifies the IPv6 WAN connection type. Must be one of either `disabled`, `static`, or `dhcpv6`.",
						},
						"wan_username": schema.StringAttribute{
							Computed:            true,
							Description:         "Specifies the IPv4 WAN username.",
							MarkdownDescription: "Specifies the IPv4 WAN username.",
						},
					},
					CustomType: NetworksType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed:            true,
				Description:         "The list of Networks associated with the site.",
				MarkdownDescription: "The list of Networks associated with the site.",
			},
			"site": schema.StringAttribute{
				Optional:            true,
				Description:         "The name of the site the Networks are associated with.",
				MarkdownDescription: "The name of the site the Networks are associated with.",
			},
		},
	}
}

type NetworksModel struct {
	Networks types.List   `tfsdk:"networks"`
	Site     types.String `tfsdk:"site"`
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoScaleEnabledAttribute, ok := attributes["auto_scale_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scale_enabled is missing from object`)

		return nil, diags
	}

	autoScaleEnabledVal, ok := autoScaleEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scale_enabled expected to be basetypes.BoolValue, was: %T`, autoScaleEnabledAttribute))
	}

	dhcpBootEnabledAttribute, ok := attributes["dhcp_boot_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_boot_enabled is missing from object`)

		return nil, diags
	}

	dhcpBootEnabledVal, ok := dhcpBootEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_boot_enabled expected to be basetypes.BoolValue, was: %T`, dhcpBootEnabledAttribute))
	}

	dhcpBootFilenameAttribute, ok := attributes["dhcp_boot_filename"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_boot_filename is missing from object`)

		return nil, diags
	}

	dhcpBootFilenameVal, ok := dhcpBootFilenameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_boot_filename expected to be basetypes.StringValue, was: %T`, dhcpBootFilenameAttribute))
	}

	dhcpBootServerAttribute, ok := attributes["dhcp_boot_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_boot_server is missing from object`)

		return nil, diags
	}

	dhcpBootServerVal, ok := dhcpBootServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_boot_server expected to be basetypes.StringValue, was: %T`, dhcpBootServerAttribute))
	}

	dhcpConflictCheckingAttribute, ok := attributes["dhcp_conflict_checking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_conflict_checking is missing from object`)

		return nil, diags
	}

	dhcpConflictCheckingVal, ok := dhcpConflictCheckingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_conflict_checking expected to be basetypes.BoolValue, was: %T`, dhcpConflictCheckingAttribute))
	}

	dhcpDnsAttribute, ok := attributes["dhcp_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_dns is missing from object`)

		return nil, diags
	}

	dhcpDnsVal, ok := dhcpDnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_dns expected to be basetypes.ListValue, was: %T`, dhcpDnsAttribute))
	}

	dhcpDnsEnabledAttribute, ok := attributes["dhcp_dns_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_dns_enabled is missing from object`)

		return nil, diags
	}

	dhcpDnsEnabledVal, ok := dhcpDnsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_dns_enabled expected to be basetypes.BoolValue, was: %T`, dhcpDnsEnabledAttribute))
	}

	dhcpEnabledAttribute, ok := attributes["dhcp_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_enabled is missing from object`)

		return nil, diags
	}

	dhcpEnabledVal, ok := dhcpEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_enabled expected to be basetypes.BoolValue, was: %T`, dhcpEnabledAttribute))
	}

	dhcpGatewayEnabledAttribute, ok := attributes["dhcp_gateway_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_gateway_enabled is missing from object`)

		return nil, diags
	}

	dhcpGatewayEnabledVal, ok := dhcpGatewayEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_gateway_enabled expected to be basetypes.BoolValue, was: %T`, dhcpGatewayEnabledAttribute))
	}

	dhcpGuardEnabledAttribute, ok := attributes["dhcp_guard_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_guard_enabled is missing from object`)

		return nil, diags
	}

	dhcpGuardEnabledVal, ok := dhcpGuardEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_guard_enabled expected to be basetypes.BoolValue, was: %T`, dhcpGuardEnabledAttribute))
	}

	dhcpLeaseTimeAttribute, ok := attributes["dhcp_lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_lease_time is missing from object`)

		return nil, diags
	}

	dhcpLeaseTimeVal, ok := dhcpLeaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_lease_time expected to be basetypes.Int64Value, was: %T`, dhcpLeaseTimeAttribute))
	}

	dhcpNtpEnabledAttribute, ok := attributes["dhcp_ntp_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_ntp_enabled is missing from object`)

		return nil, diags
	}

	dhcpNtpEnabledVal, ok := dhcpNtpEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_ntp_enabled expected to be basetypes.BoolValue, was: %T`, dhcpNtpEnabledAttribute))
	}

	dhcpRelayEnabledAttribute, ok := attributes["dhcp_relay_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_relay_enabled is missing from object`)

		return nil, diags
	}

	dhcpRelayEnabledVal, ok := dhcpRelayEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_relay_enabled expected to be basetypes.BoolValue, was: %T`, dhcpRelayEnabledAttribute))
	}

	dhcpStartAttribute, ok := attributes["dhcp_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_start is missing from object`)

		return nil, diags
	}

	dhcpStartVal, ok := dhcpStartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_start expected to be basetypes.StringValue, was: %T`, dhcpStartAttribute))
	}

	dhcpStopAttribute, ok := attributes["dhcp_stop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_stop is missing from object`)

		return nil, diags
	}

	dhcpStopVal, ok := dhcpStopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_stop expected to be basetypes.StringValue, was: %T`, dhcpStopAttribute))
	}

	dhcpTftpServerAttribute, ok := attributes["dhcp_tftp_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_tftp_server is missing from object`)

		return nil, diags
	}

	dhcpTftpServerVal, ok := dhcpTftpServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_tftp_server expected to be basetypes.StringValue, was: %T`, dhcpTftpServerAttribute))
	}

	dhcpTimeOffsetEnabledAttribute, ok := attributes["dhcp_time_offset_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_time_offset_enabled is missing from object`)

		return nil, diags
	}

	dhcpTimeOffsetEnabledVal, ok := dhcpTimeOffsetEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_time_offset_enabled expected to be basetypes.BoolValue, was: %T`, dhcpTimeOffsetEnabledAttribute))
	}

	dhcpUnifiControllerAttribute, ok := attributes["dhcp_unifi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_unifi_controller is missing from object`)

		return nil, diags
	}

	dhcpUnifiControllerVal, ok := dhcpUnifiControllerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_unifi_controller expected to be basetypes.StringValue, was: %T`, dhcpUnifiControllerAttribute))
	}

	dhcpV6AllowSlaacAttribute, ok := attributes["dhcp_v6_allow_slaac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_allow_slaac is missing from object`)

		return nil, diags
	}

	dhcpV6AllowSlaacVal, ok := dhcpV6AllowSlaacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_allow_slaac expected to be basetypes.BoolValue, was: %T`, dhcpV6AllowSlaacAttribute))
	}

	dhcpV6DnsAttribute, ok := attributes["dhcp_v6_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_dns is missing from object`)

		return nil, diags
	}

	dhcpV6DnsVal, ok := dhcpV6DnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_dns expected to be basetypes.ListValue, was: %T`, dhcpV6DnsAttribute))
	}

	dhcpV6DnsAutoAttribute, ok := attributes["dhcp_v6_dns_auto"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_dns_auto is missing from object`)

		return nil, diags
	}

	dhcpV6DnsAutoVal, ok := dhcpV6DnsAutoAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_dns_auto expected to be basetypes.BoolValue, was: %T`, dhcpV6DnsAutoAttribute))
	}

	dhcpV6EnabledAttribute, ok := attributes["dhcp_v6_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_enabled is missing from object`)

		return nil, diags
	}

	dhcpV6EnabledVal, ok := dhcpV6EnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_enabled expected to be basetypes.BoolValue, was: %T`, dhcpV6EnabledAttribute))
	}

	dhcpV6LeaseTimeAttribute, ok := attributes["dhcp_v6_lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_lease_time is missing from object`)

		return nil, diags
	}

	dhcpV6LeaseTimeVal, ok := dhcpV6LeaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_lease_time expected to be basetypes.Int64Value, was: %T`, dhcpV6LeaseTimeAttribute))
	}

	dhcpV6StartAttribute, ok := attributes["dhcp_v6_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_start is missing from object`)

		return nil, diags
	}

	dhcpV6StartVal, ok := dhcpV6StartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_start expected to be basetypes.StringValue, was: %T`, dhcpV6StartAttribute))
	}

	dhcpV6StopAttribute, ok := attributes["dhcp_v6_stop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_stop is missing from object`)

		return nil, diags
	}

	dhcpV6StopVal, ok := dhcpV6StopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_stop expected to be basetypes.StringValue, was: %T`, dhcpV6StopAttribute))
	}

	dhcpWinsEnabledAttribute, ok := attributes["dhcp_wins_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_wins_enabled is missing from object`)

		return nil, diags
	}

	dhcpWinsEnabledVal, ok := dhcpWinsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_wins_enabled expected to be basetypes.BoolValue, was: %T`, dhcpWinsEnabledAttribute))
	}

	dhcpWpadUrlAttribute, ok := attributes["dhcp_wpad_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_wpad_url is missing from object`)

		return nil, diags
	}

	dhcpWpadUrlVal, ok := dhcpWpadUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_wpad_url expected to be basetypes.StringValue, was: %T`, dhcpWpadUrlAttribute))
	}

	domainNameAttribute, ok := attributes["domain_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_name is missing from object`)

		return nil, diags
	}

	domainNameVal, ok := domainNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_name expected to be basetypes.StringValue, was: %T`, domainNameAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	gatewayTypeAttribute, ok := attributes["gateway_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_type is missing from object`)

		return nil, diags
	}

	gatewayTypeVal, ok := gatewayTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_type expected to be basetypes.StringValue, was: %T`, gatewayTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	igmpSnoopingAttribute, ok := attributes["igmp_snooping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`igmp_snooping is missing from object`)

		return nil, diags
	}

	igmpSnoopingVal, ok := igmpSnoopingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`igmp_snooping expected to be basetypes.BoolValue, was: %T`, igmpSnoopingAttribute))
	}

	internetAccessEnabledAttribute, ok := attributes["internet_access_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_access_enabled is missing from object`)

		return nil, diags
	}

	internetAccessEnabledVal, ok := internetAccessEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_access_enabled expected to be basetypes.BoolValue, was: %T`, internetAccessEnabledAttribute))
	}

	ipv6ClientAddressAssignmentAttribute, ok := attributes["ipv6_client_address_assignment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_client_address_assignment is missing from object`)

		return nil, diags
	}

	ipv6ClientAddressAssignmentVal, ok := ipv6ClientAddressAssignmentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_client_address_assignment expected to be basetypes.StringValue, was: %T`, ipv6ClientAddressAssignmentAttribute))
	}

	ipv6EnabledAttribute, ok := attributes["ipv6_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_enabled is missing from object`)

		return nil, diags
	}

	ipv6EnabledVal, ok := ipv6EnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_enabled expected to be basetypes.BoolValue, was: %T`, ipv6EnabledAttribute))
	}

	ipv6InterfaceTypeAttribute, ok := attributes["ipv6_interface_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_interface_type is missing from object`)

		return nil, diags
	}

	ipv6InterfaceTypeVal, ok := ipv6InterfaceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_interface_type expected to be basetypes.StringValue, was: %T`, ipv6InterfaceTypeAttribute))
	}

	ipv6PdAutoPrefixidEnabledAttribute, ok := attributes["ipv6_pd_auto_prefixid_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pd_auto_prefixid_enabled is missing from object`)

		return nil, diags
	}

	ipv6PdAutoPrefixidEnabledVal, ok := ipv6PdAutoPrefixidEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pd_auto_prefixid_enabled expected to be basetypes.BoolValue, was: %T`, ipv6PdAutoPrefixidEnabledAttribute))
	}

	ipv6PdInterfaceAttribute, ok := attributes["ipv6_pd_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pd_interface is missing from object`)

		return nil, diags
	}

	ipv6PdInterfaceVal, ok := ipv6PdInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pd_interface expected to be basetypes.StringValue, was: %T`, ipv6PdInterfaceAttribute))
	}

	ipv6PdPrefixidAttribute, ok := attributes["ipv6_pd_prefixid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pd_prefixid is missing from object`)

		return nil, diags
	}

	ipv6PdPrefixidVal, ok := ipv6PdPrefixidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pd_prefixid expected to be basetypes.StringValue, was: %T`, ipv6PdPrefixidAttribute))
	}

	ipv6PdStartAttribute, ok := attributes["ipv6_pd_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pd_start is missing from object`)

		return nil, diags
	}

	ipv6PdStartVal, ok := ipv6PdStartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pd_start expected to be basetypes.StringValue, was: %T`, ipv6PdStartAttribute))
	}

	ipv6PdStopAttribute, ok := attributes["ipv6_pd_stop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pd_stop is missing from object`)

		return nil, diags
	}

	ipv6PdStopVal, ok := ipv6PdStopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pd_stop expected to be basetypes.StringValue, was: %T`, ipv6PdStopAttribute))
	}

	ipv6RaEnabledAttribute, ok := attributes["ipv6_ra_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_ra_enabled is missing from object`)

		return nil, diags
	}

	ipv6RaEnabledVal, ok := ipv6RaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_ra_enabled expected to be basetypes.BoolValue, was: %T`, ipv6RaEnabledAttribute))
	}

	ipv6RaPreferredLifetimeAttribute, ok := attributes["ipv6_ra_preferred_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_ra_preferred_lifetime is missing from object`)

		return nil, diags
	}

	ipv6RaPreferredLifetimeVal, ok := ipv6RaPreferredLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_ra_preferred_lifetime expected to be basetypes.Int64Value, was: %T`, ipv6RaPreferredLifetimeAttribute))
	}

	ipv6RaPriorityAttribute, ok := attributes["ipv6_ra_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_ra_priority is missing from object`)

		return nil, diags
	}

	ipv6RaPriorityVal, ok := ipv6RaPriorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_ra_priority expected to be basetypes.StringValue, was: %T`, ipv6RaPriorityAttribute))
	}

	ipv6RaValidLifetimeAttribute, ok := attributes["ipv6_ra_valid_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_ra_valid_lifetime is missing from object`)

		return nil, diags
	}

	ipv6RaValidLifetimeVal, ok := ipv6RaValidLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_ra_valid_lifetime expected to be basetypes.Int64Value, was: %T`, ipv6RaValidLifetimeAttribute))
	}

	ipv6SettingPreferenceAttribute, ok := attributes["ipv6_setting_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_setting_preference is missing from object`)

		return nil, diags
	}

	ipv6SettingPreferenceVal, ok := ipv6SettingPreferenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_setting_preference expected to be basetypes.StringValue, was: %T`, ipv6SettingPreferenceAttribute))
	}

	ipv6StaticSubnetAttribute, ok := attributes["ipv6_static_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_static_subnet is missing from object`)

		return nil, diags
	}

	ipv6StaticSubnetVal, ok := ipv6StaticSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_static_subnet expected to be basetypes.StringValue, was: %T`, ipv6StaticSubnetAttribute))
	}

	lteLanEnabledAttribute, ok := attributes["lte_lan_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_lan_enabled is missing from object`)

		return nil, diags
	}

	lteLanEnabledVal, ok := lteLanEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_lan_enabled expected to be basetypes.BoolValue, was: %T`, lteLanEnabledAttribute))
	}

	multicastDnsEnabledAttribute, ok := attributes["multicast_dns_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multicast_dns_enabled is missing from object`)

		return nil, diags
	}

	multicastDnsEnabledVal, ok := multicastDnsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multicast_dns_enabled expected to be basetypes.BoolValue, was: %T`, multicastDnsEnabledAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	natOutboundIpAddressesAttribute, ok := attributes["nat_outbound_ip_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_outbound_ip_addresses is missing from object`)

		return nil, diags
	}

	natOutboundIpAddressesVal, ok := natOutboundIpAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_outbound_ip_addresses expected to be basetypes.ListValue, was: %T`, natOutboundIpAddressesAttribute))
	}

	networkGroupAttribute, ok := attributes["network_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_group is missing from object`)

		return nil, diags
	}

	networkGroupVal, ok := networkGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_group expected to be basetypes.StringValue, was: %T`, networkGroupAttribute))
	}

	networkIsolationEnabledAttribute, ok := attributes["network_isolation_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_isolation_enabled is missing from object`)

		return nil, diags
	}

	networkIsolationEnabledVal, ok := networkIsolationEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_isolation_enabled expected to be basetypes.BoolValue, was: %T`, networkIsolationEnabledAttribute))
	}

	purposeAttribute, ok := attributes["purpose"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`purpose is missing from object`)

		return nil, diags
	}

	purposeVal, ok := purposeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`purpose expected to be basetypes.StringValue, was: %T`, purposeAttribute))
	}

	settingPreferenceAttribute, ok := attributes["setting_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`setting_preference is missing from object`)

		return nil, diags
	}

	settingPreferenceVal, ok := settingPreferenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`setting_preference expected to be basetypes.StringValue, was: %T`, settingPreferenceAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return nil, diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	upnpLanEnabledAttribute, ok := attributes["upnp_lan_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upnp_lan_enabled is missing from object`)

		return nil, diags
	}

	upnpLanEnabledVal, ok := upnpLanEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upnp_lan_enabled expected to be basetypes.BoolValue, was: %T`, upnpLanEnabledAttribute))
	}

	vlanEnabledAttribute, ok := attributes["vlan_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_enabled is missing from object`)

		return nil, diags
	}

	vlanEnabledVal, ok := vlanEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_enabled expected to be basetypes.BoolValue, was: %T`, vlanEnabledAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	wanDhcpV6PdSizeAttribute, ok := attributes["wan_dhcp_v6_pd_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_dhcp_v6_pd_size is missing from object`)

		return nil, diags
	}

	wanDhcpV6PdSizeVal, ok := wanDhcpV6PdSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_dhcp_v6_pd_size expected to be basetypes.Int64Value, was: %T`, wanDhcpV6PdSizeAttribute))
	}

	wanDnsAttribute, ok := attributes["wan_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_dns is missing from object`)

		return nil, diags
	}

	wanDnsVal, ok := wanDnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_dns expected to be basetypes.ListValue, was: %T`, wanDnsAttribute))
	}

	wanEgressQosAttribute, ok := attributes["wan_egress_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_egress_qos is missing from object`)

		return nil, diags
	}

	wanEgressQosVal, ok := wanEgressQosAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_egress_qos expected to be basetypes.Int64Value, was: %T`, wanEgressQosAttribute))
	}

	wanGatewayAttribute, ok := attributes["wan_gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_gateway is missing from object`)

		return nil, diags
	}

	wanGatewayVal, ok := wanGatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_gateway expected to be basetypes.StringValue, was: %T`, wanGatewayAttribute))
	}

	wanGatewayV6Attribute, ok := attributes["wan_gateway_v6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_gateway_v6 is missing from object`)

		return nil, diags
	}

	wanGatewayV6Val, ok := wanGatewayV6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_gateway_v6 expected to be basetypes.StringValue, was: %T`, wanGatewayV6Attribute))
	}

	wanIpAttribute, ok := attributes["wan_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_ip is missing from object`)

		return nil, diags
	}

	wanIpVal, ok := wanIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_ip expected to be basetypes.StringValue, was: %T`, wanIpAttribute))
	}

	wanIpv6Attribute, ok := attributes["wan_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_ipv6 is missing from object`)

		return nil, diags
	}

	wanIpv6Val, ok := wanIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_ipv6 expected to be basetypes.StringValue, was: %T`, wanIpv6Attribute))
	}

	wanNetmaskAttribute, ok := attributes["wan_netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_netmask is missing from object`)

		return nil, diags
	}

	wanNetmaskVal, ok := wanNetmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_netmask expected to be basetypes.StringValue, was: %T`, wanNetmaskAttribute))
	}

	wanNetworkGroupAttribute, ok := attributes["wan_network_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_network_group is missing from object`)

		return nil, diags
	}

	wanNetworkGroupVal, ok := wanNetworkGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_network_group expected to be basetypes.StringValue, was: %T`, wanNetworkGroupAttribute))
	}

	wanPasswordAttribute, ok := attributes["wan_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_password is missing from object`)

		return nil, diags
	}

	wanPasswordVal, ok := wanPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_password expected to be basetypes.StringValue, was: %T`, wanPasswordAttribute))
	}

	wanPrefixlenAttribute, ok := attributes["wan_prefixlen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_prefixlen is missing from object`)

		return nil, diags
	}

	wanPrefixlenVal, ok := wanPrefixlenAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_prefixlen expected to be basetypes.Int64Value, was: %T`, wanPrefixlenAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return nil, diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	wanTypeV6Attribute, ok := attributes["wan_type_v6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type_v6 is missing from object`)

		return nil, diags
	}

	wanTypeV6Val, ok := wanTypeV6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type_v6 expected to be basetypes.StringValue, was: %T`, wanTypeV6Attribute))
	}

	wanUsernameAttribute, ok := attributes["wan_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_username is missing from object`)

		return nil, diags
	}

	wanUsernameVal, ok := wanUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_username expected to be basetypes.StringValue, was: %T`, wanUsernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		AutoScaleEnabled:            autoScaleEnabledVal,
		DhcpBootEnabled:             dhcpBootEnabledVal,
		DhcpBootFilename:            dhcpBootFilenameVal,
		DhcpBootServer:              dhcpBootServerVal,
		DhcpConflictChecking:        dhcpConflictCheckingVal,
		DhcpDns:                     dhcpDnsVal,
		DhcpDnsEnabled:              dhcpDnsEnabledVal,
		DhcpEnabled:                 dhcpEnabledVal,
		DhcpGatewayEnabled:          dhcpGatewayEnabledVal,
		DhcpGuardEnabled:            dhcpGuardEnabledVal,
		DhcpLeaseTime:               dhcpLeaseTimeVal,
		DhcpNtpEnabled:              dhcpNtpEnabledVal,
		DhcpRelayEnabled:            dhcpRelayEnabledVal,
		DhcpStart:                   dhcpStartVal,
		DhcpStop:                    dhcpStopVal,
		DhcpTftpServer:              dhcpTftpServerVal,
		DhcpTimeOffsetEnabled:       dhcpTimeOffsetEnabledVal,
		DhcpUnifiController:         dhcpUnifiControllerVal,
		DhcpV6AllowSlaac:            dhcpV6AllowSlaacVal,
		DhcpV6Dns:                   dhcpV6DnsVal,
		DhcpV6DnsAuto:               dhcpV6DnsAutoVal,
		DhcpV6Enabled:               dhcpV6EnabledVal,
		DhcpV6LeaseTime:             dhcpV6LeaseTimeVal,
		DhcpV6Start:                 dhcpV6StartVal,
		DhcpV6Stop:                  dhcpV6StopVal,
		DhcpWinsEnabled:             dhcpWinsEnabledVal,
		DhcpWpadUrl:                 dhcpWpadUrlVal,
		DomainName:                  domainNameVal,
		Enabled:                     enabledVal,
		GatewayType:                 gatewayTypeVal,
		Id:                          idVal,
		IgmpSnooping:                igmpSnoopingVal,
		InternetAccessEnabled:       internetAccessEnabledVal,
		Ipv6ClientAddressAssignment: ipv6ClientAddressAssignmentVal,
		Ipv6Enabled:                 ipv6EnabledVal,
		Ipv6InterfaceType:           ipv6InterfaceTypeVal,
		Ipv6PdAutoPrefixidEnabled:   ipv6PdAutoPrefixidEnabledVal,
		Ipv6PdInterface:             ipv6PdInterfaceVal,
		Ipv6PdPrefixid:              ipv6PdPrefixidVal,
		Ipv6PdStart:                 ipv6PdStartVal,
		Ipv6PdStop:                  ipv6PdStopVal,
		Ipv6RaEnabled:               ipv6RaEnabledVal,
		Ipv6RaPreferredLifetime:     ipv6RaPreferredLifetimeVal,
		Ipv6RaPriority:              ipv6RaPriorityVal,
		Ipv6RaValidLifetime:         ipv6RaValidLifetimeVal,
		Ipv6SettingPreference:       ipv6SettingPreferenceVal,
		Ipv6StaticSubnet:            ipv6StaticSubnetVal,
		LteLanEnabled:               lteLanEnabledVal,
		MulticastDnsEnabled:         multicastDnsEnabledVal,
		Name:                        nameVal,
		NatOutboundIpAddresses:      natOutboundIpAddressesVal,
		NetworkGroup:                networkGroupVal,
		NetworkIsolationEnabled:     networkIsolationEnabledVal,
		Purpose:                     purposeVal,
		SettingPreference:           settingPreferenceVal,
		SiteId:                      siteIdVal,
		Subnet:                      subnetVal,
		UpnpLanEnabled:              upnpLanEnabledVal,
		VlanEnabled:                 vlanEnabledVal,
		VlanId:                      vlanIdVal,
		WanDhcpV6PdSize:             wanDhcpV6PdSizeVal,
		WanDns:                      wanDnsVal,
		WanEgressQos:                wanEgressQosVal,
		WanGateway:                  wanGatewayVal,
		WanGatewayV6:                wanGatewayV6Val,
		WanIp:                       wanIpVal,
		WanIpv6:                     wanIpv6Val,
		WanNetmask:                  wanNetmaskVal,
		WanNetworkGroup:             wanNetworkGroupVal,
		WanPassword:                 wanPasswordVal,
		WanPrefixlen:                wanPrefixlenVal,
		WanType:                     wanTypeVal,
		WanTypeV6:                   wanTypeV6Val,
		WanUsername:                 wanUsernameVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	autoScaleEnabledAttribute, ok := attributes["auto_scale_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_scale_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	autoScaleEnabledVal, ok := autoScaleEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_scale_enabled expected to be basetypes.BoolValue, was: %T`, autoScaleEnabledAttribute))
	}

	dhcpBootEnabledAttribute, ok := attributes["dhcp_boot_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_boot_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpBootEnabledVal, ok := dhcpBootEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_boot_enabled expected to be basetypes.BoolValue, was: %T`, dhcpBootEnabledAttribute))
	}

	dhcpBootFilenameAttribute, ok := attributes["dhcp_boot_filename"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_boot_filename is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpBootFilenameVal, ok := dhcpBootFilenameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_boot_filename expected to be basetypes.StringValue, was: %T`, dhcpBootFilenameAttribute))
	}

	dhcpBootServerAttribute, ok := attributes["dhcp_boot_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_boot_server is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpBootServerVal, ok := dhcpBootServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_boot_server expected to be basetypes.StringValue, was: %T`, dhcpBootServerAttribute))
	}

	dhcpConflictCheckingAttribute, ok := attributes["dhcp_conflict_checking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_conflict_checking is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpConflictCheckingVal, ok := dhcpConflictCheckingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_conflict_checking expected to be basetypes.BoolValue, was: %T`, dhcpConflictCheckingAttribute))
	}

	dhcpDnsAttribute, ok := attributes["dhcp_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_dns is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpDnsVal, ok := dhcpDnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_dns expected to be basetypes.ListValue, was: %T`, dhcpDnsAttribute))
	}

	dhcpDnsEnabledAttribute, ok := attributes["dhcp_dns_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_dns_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpDnsEnabledVal, ok := dhcpDnsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_dns_enabled expected to be basetypes.BoolValue, was: %T`, dhcpDnsEnabledAttribute))
	}

	dhcpEnabledAttribute, ok := attributes["dhcp_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpEnabledVal, ok := dhcpEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_enabled expected to be basetypes.BoolValue, was: %T`, dhcpEnabledAttribute))
	}

	dhcpGatewayEnabledAttribute, ok := attributes["dhcp_gateway_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_gateway_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpGatewayEnabledVal, ok := dhcpGatewayEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_gateway_enabled expected to be basetypes.BoolValue, was: %T`, dhcpGatewayEnabledAttribute))
	}

	dhcpGuardEnabledAttribute, ok := attributes["dhcp_guard_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_guard_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpGuardEnabledVal, ok := dhcpGuardEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_guard_enabled expected to be basetypes.BoolValue, was: %T`, dhcpGuardEnabledAttribute))
	}

	dhcpLeaseTimeAttribute, ok := attributes["dhcp_lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_lease_time is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpLeaseTimeVal, ok := dhcpLeaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_lease_time expected to be basetypes.Int64Value, was: %T`, dhcpLeaseTimeAttribute))
	}

	dhcpNtpEnabledAttribute, ok := attributes["dhcp_ntp_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_ntp_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpNtpEnabledVal, ok := dhcpNtpEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_ntp_enabled expected to be basetypes.BoolValue, was: %T`, dhcpNtpEnabledAttribute))
	}

	dhcpRelayEnabledAttribute, ok := attributes["dhcp_relay_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_relay_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpRelayEnabledVal, ok := dhcpRelayEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_relay_enabled expected to be basetypes.BoolValue, was: %T`, dhcpRelayEnabledAttribute))
	}

	dhcpStartAttribute, ok := attributes["dhcp_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_start is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpStartVal, ok := dhcpStartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_start expected to be basetypes.StringValue, was: %T`, dhcpStartAttribute))
	}

	dhcpStopAttribute, ok := attributes["dhcp_stop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_stop is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpStopVal, ok := dhcpStopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_stop expected to be basetypes.StringValue, was: %T`, dhcpStopAttribute))
	}

	dhcpTftpServerAttribute, ok := attributes["dhcp_tftp_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_tftp_server is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpTftpServerVal, ok := dhcpTftpServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_tftp_server expected to be basetypes.StringValue, was: %T`, dhcpTftpServerAttribute))
	}

	dhcpTimeOffsetEnabledAttribute, ok := attributes["dhcp_time_offset_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_time_offset_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpTimeOffsetEnabledVal, ok := dhcpTimeOffsetEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_time_offset_enabled expected to be basetypes.BoolValue, was: %T`, dhcpTimeOffsetEnabledAttribute))
	}

	dhcpUnifiControllerAttribute, ok := attributes["dhcp_unifi_controller"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_unifi_controller is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpUnifiControllerVal, ok := dhcpUnifiControllerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_unifi_controller expected to be basetypes.StringValue, was: %T`, dhcpUnifiControllerAttribute))
	}

	dhcpV6AllowSlaacAttribute, ok := attributes["dhcp_v6_allow_slaac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_allow_slaac is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpV6AllowSlaacVal, ok := dhcpV6AllowSlaacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_allow_slaac expected to be basetypes.BoolValue, was: %T`, dhcpV6AllowSlaacAttribute))
	}

	dhcpV6DnsAttribute, ok := attributes["dhcp_v6_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_dns is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpV6DnsVal, ok := dhcpV6DnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_dns expected to be basetypes.ListValue, was: %T`, dhcpV6DnsAttribute))
	}

	dhcpV6DnsAutoAttribute, ok := attributes["dhcp_v6_dns_auto"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_dns_auto is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpV6DnsAutoVal, ok := dhcpV6DnsAutoAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_dns_auto expected to be basetypes.BoolValue, was: %T`, dhcpV6DnsAutoAttribute))
	}

	dhcpV6EnabledAttribute, ok := attributes["dhcp_v6_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpV6EnabledVal, ok := dhcpV6EnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_enabled expected to be basetypes.BoolValue, was: %T`, dhcpV6EnabledAttribute))
	}

	dhcpV6LeaseTimeAttribute, ok := attributes["dhcp_v6_lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_lease_time is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpV6LeaseTimeVal, ok := dhcpV6LeaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_lease_time expected to be basetypes.Int64Value, was: %T`, dhcpV6LeaseTimeAttribute))
	}

	dhcpV6StartAttribute, ok := attributes["dhcp_v6_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_start is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpV6StartVal, ok := dhcpV6StartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_start expected to be basetypes.StringValue, was: %T`, dhcpV6StartAttribute))
	}

	dhcpV6StopAttribute, ok := attributes["dhcp_v6_stop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_v6_stop is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpV6StopVal, ok := dhcpV6StopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_v6_stop expected to be basetypes.StringValue, was: %T`, dhcpV6StopAttribute))
	}

	dhcpWinsEnabledAttribute, ok := attributes["dhcp_wins_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_wins_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpWinsEnabledVal, ok := dhcpWinsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_wins_enabled expected to be basetypes.BoolValue, was: %T`, dhcpWinsEnabledAttribute))
	}

	dhcpWpadUrlAttribute, ok := attributes["dhcp_wpad_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_wpad_url is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	dhcpWpadUrlVal, ok := dhcpWpadUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_wpad_url expected to be basetypes.StringValue, was: %T`, dhcpWpadUrlAttribute))
	}

	domainNameAttribute, ok := attributes["domain_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_name is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	domainNameVal, ok := domainNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_name expected to be basetypes.StringValue, was: %T`, domainNameAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	gatewayTypeAttribute, ok := attributes["gateway_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_type is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	gatewayTypeVal, ok := gatewayTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_type expected to be basetypes.StringValue, was: %T`, gatewayTypeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	igmpSnoopingAttribute, ok := attributes["igmp_snooping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`igmp_snooping is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	igmpSnoopingVal, ok := igmpSnoopingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`igmp_snooping expected to be basetypes.BoolValue, was: %T`, igmpSnoopingAttribute))
	}

	internetAccessEnabledAttribute, ok := attributes["internet_access_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_access_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	internetAccessEnabledVal, ok := internetAccessEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_access_enabled expected to be basetypes.BoolValue, was: %T`, internetAccessEnabledAttribute))
	}

	ipv6ClientAddressAssignmentAttribute, ok := attributes["ipv6_client_address_assignment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_client_address_assignment is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6ClientAddressAssignmentVal, ok := ipv6ClientAddressAssignmentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_client_address_assignment expected to be basetypes.StringValue, was: %T`, ipv6ClientAddressAssignmentAttribute))
	}

	ipv6EnabledAttribute, ok := attributes["ipv6_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6EnabledVal, ok := ipv6EnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_enabled expected to be basetypes.BoolValue, was: %T`, ipv6EnabledAttribute))
	}

	ipv6InterfaceTypeAttribute, ok := attributes["ipv6_interface_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_interface_type is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6InterfaceTypeVal, ok := ipv6InterfaceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_interface_type expected to be basetypes.StringValue, was: %T`, ipv6InterfaceTypeAttribute))
	}

	ipv6PdAutoPrefixidEnabledAttribute, ok := attributes["ipv6_pd_auto_prefixid_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pd_auto_prefixid_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6PdAutoPrefixidEnabledVal, ok := ipv6PdAutoPrefixidEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pd_auto_prefixid_enabled expected to be basetypes.BoolValue, was: %T`, ipv6PdAutoPrefixidEnabledAttribute))
	}

	ipv6PdInterfaceAttribute, ok := attributes["ipv6_pd_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pd_interface is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6PdInterfaceVal, ok := ipv6PdInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pd_interface expected to be basetypes.StringValue, was: %T`, ipv6PdInterfaceAttribute))
	}

	ipv6PdPrefixidAttribute, ok := attributes["ipv6_pd_prefixid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pd_prefixid is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6PdPrefixidVal, ok := ipv6PdPrefixidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pd_prefixid expected to be basetypes.StringValue, was: %T`, ipv6PdPrefixidAttribute))
	}

	ipv6PdStartAttribute, ok := attributes["ipv6_pd_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pd_start is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6PdStartVal, ok := ipv6PdStartAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pd_start expected to be basetypes.StringValue, was: %T`, ipv6PdStartAttribute))
	}

	ipv6PdStopAttribute, ok := attributes["ipv6_pd_stop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_pd_stop is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6PdStopVal, ok := ipv6PdStopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_pd_stop expected to be basetypes.StringValue, was: %T`, ipv6PdStopAttribute))
	}

	ipv6RaEnabledAttribute, ok := attributes["ipv6_ra_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_ra_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6RaEnabledVal, ok := ipv6RaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_ra_enabled expected to be basetypes.BoolValue, was: %T`, ipv6RaEnabledAttribute))
	}

	ipv6RaPreferredLifetimeAttribute, ok := attributes["ipv6_ra_preferred_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_ra_preferred_lifetime is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6RaPreferredLifetimeVal, ok := ipv6RaPreferredLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_ra_preferred_lifetime expected to be basetypes.Int64Value, was: %T`, ipv6RaPreferredLifetimeAttribute))
	}

	ipv6RaPriorityAttribute, ok := attributes["ipv6_ra_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_ra_priority is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6RaPriorityVal, ok := ipv6RaPriorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_ra_priority expected to be basetypes.StringValue, was: %T`, ipv6RaPriorityAttribute))
	}

	ipv6RaValidLifetimeAttribute, ok := attributes["ipv6_ra_valid_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_ra_valid_lifetime is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6RaValidLifetimeVal, ok := ipv6RaValidLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_ra_valid_lifetime expected to be basetypes.Int64Value, was: %T`, ipv6RaValidLifetimeAttribute))
	}

	ipv6SettingPreferenceAttribute, ok := attributes["ipv6_setting_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_setting_preference is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6SettingPreferenceVal, ok := ipv6SettingPreferenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_setting_preference expected to be basetypes.StringValue, was: %T`, ipv6SettingPreferenceAttribute))
	}

	ipv6StaticSubnetAttribute, ok := attributes["ipv6_static_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_static_subnet is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6StaticSubnetVal, ok := ipv6StaticSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_static_subnet expected to be basetypes.StringValue, was: %T`, ipv6StaticSubnetAttribute))
	}

	lteLanEnabledAttribute, ok := attributes["lte_lan_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_lan_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	lteLanEnabledVal, ok := lteLanEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_lan_enabled expected to be basetypes.BoolValue, was: %T`, lteLanEnabledAttribute))
	}

	multicastDnsEnabledAttribute, ok := attributes["multicast_dns_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multicast_dns_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	multicastDnsEnabledVal, ok := multicastDnsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multicast_dns_enabled expected to be basetypes.BoolValue, was: %T`, multicastDnsEnabledAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	natOutboundIpAddressesAttribute, ok := attributes["nat_outbound_ip_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_outbound_ip_addresses is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	natOutboundIpAddressesVal, ok := natOutboundIpAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_outbound_ip_addresses expected to be basetypes.ListValue, was: %T`, natOutboundIpAddressesAttribute))
	}

	networkGroupAttribute, ok := attributes["network_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_group is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	networkGroupVal, ok := networkGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_group expected to be basetypes.StringValue, was: %T`, networkGroupAttribute))
	}

	networkIsolationEnabledAttribute, ok := attributes["network_isolation_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_isolation_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	networkIsolationEnabledVal, ok := networkIsolationEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_isolation_enabled expected to be basetypes.BoolValue, was: %T`, networkIsolationEnabledAttribute))
	}

	purposeAttribute, ok := attributes["purpose"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`purpose is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	purposeVal, ok := purposeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`purpose expected to be basetypes.StringValue, was: %T`, purposeAttribute))
	}

	settingPreferenceAttribute, ok := attributes["setting_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`setting_preference is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	settingPreferenceVal, ok := settingPreferenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`setting_preference expected to be basetypes.StringValue, was: %T`, settingPreferenceAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	upnpLanEnabledAttribute, ok := attributes["upnp_lan_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upnp_lan_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	upnpLanEnabledVal, ok := upnpLanEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upnp_lan_enabled expected to be basetypes.BoolValue, was: %T`, upnpLanEnabledAttribute))
	}

	vlanEnabledAttribute, ok := attributes["vlan_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_enabled is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanEnabledVal, ok := vlanEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_enabled expected to be basetypes.BoolValue, was: %T`, vlanEnabledAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	wanDhcpV6PdSizeAttribute, ok := attributes["wan_dhcp_v6_pd_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_dhcp_v6_pd_size is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanDhcpV6PdSizeVal, ok := wanDhcpV6PdSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_dhcp_v6_pd_size expected to be basetypes.Int64Value, was: %T`, wanDhcpV6PdSizeAttribute))
	}

	wanDnsAttribute, ok := attributes["wan_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_dns is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanDnsVal, ok := wanDnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_dns expected to be basetypes.ListValue, was: %T`, wanDnsAttribute))
	}

	wanEgressQosAttribute, ok := attributes["wan_egress_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_egress_qos is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanEgressQosVal, ok := wanEgressQosAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_egress_qos expected to be basetypes.Int64Value, was: %T`, wanEgressQosAttribute))
	}

	wanGatewayAttribute, ok := attributes["wan_gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_gateway is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanGatewayVal, ok := wanGatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_gateway expected to be basetypes.StringValue, was: %T`, wanGatewayAttribute))
	}

	wanGatewayV6Attribute, ok := attributes["wan_gateway_v6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_gateway_v6 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanGatewayV6Val, ok := wanGatewayV6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_gateway_v6 expected to be basetypes.StringValue, was: %T`, wanGatewayV6Attribute))
	}

	wanIpAttribute, ok := attributes["wan_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_ip is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanIpVal, ok := wanIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_ip expected to be basetypes.StringValue, was: %T`, wanIpAttribute))
	}

	wanIpv6Attribute, ok := attributes["wan_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_ipv6 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanIpv6Val, ok := wanIpv6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_ipv6 expected to be basetypes.StringValue, was: %T`, wanIpv6Attribute))
	}

	wanNetmaskAttribute, ok := attributes["wan_netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_netmask is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanNetmaskVal, ok := wanNetmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_netmask expected to be basetypes.StringValue, was: %T`, wanNetmaskAttribute))
	}

	wanNetworkGroupAttribute, ok := attributes["wan_network_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_network_group is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanNetworkGroupVal, ok := wanNetworkGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_network_group expected to be basetypes.StringValue, was: %T`, wanNetworkGroupAttribute))
	}

	wanPasswordAttribute, ok := attributes["wan_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_password is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanPasswordVal, ok := wanPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_password expected to be basetypes.StringValue, was: %T`, wanPasswordAttribute))
	}

	wanPrefixlenAttribute, ok := attributes["wan_prefixlen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_prefixlen is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanPrefixlenVal, ok := wanPrefixlenAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_prefixlen expected to be basetypes.Int64Value, was: %T`, wanPrefixlenAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	wanTypeV6Attribute, ok := attributes["wan_type_v6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type_v6 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanTypeV6Val, ok := wanTypeV6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type_v6 expected to be basetypes.StringValue, was: %T`, wanTypeV6Attribute))
	}

	wanUsernameAttribute, ok := attributes["wan_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_username is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	wanUsernameVal, ok := wanUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_username expected to be basetypes.StringValue, was: %T`, wanUsernameAttribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		AutoScaleEnabled:            autoScaleEnabledVal,
		DhcpBootEnabled:             dhcpBootEnabledVal,
		DhcpBootFilename:            dhcpBootFilenameVal,
		DhcpBootServer:              dhcpBootServerVal,
		DhcpConflictChecking:        dhcpConflictCheckingVal,
		DhcpDns:                     dhcpDnsVal,
		DhcpDnsEnabled:              dhcpDnsEnabledVal,
		DhcpEnabled:                 dhcpEnabledVal,
		DhcpGatewayEnabled:          dhcpGatewayEnabledVal,
		DhcpGuardEnabled:            dhcpGuardEnabledVal,
		DhcpLeaseTime:               dhcpLeaseTimeVal,
		DhcpNtpEnabled:              dhcpNtpEnabledVal,
		DhcpRelayEnabled:            dhcpRelayEnabledVal,
		DhcpStart:                   dhcpStartVal,
		DhcpStop:                    dhcpStopVal,
		DhcpTftpServer:              dhcpTftpServerVal,
		DhcpTimeOffsetEnabled:       dhcpTimeOffsetEnabledVal,
		DhcpUnifiController:         dhcpUnifiControllerVal,
		DhcpV6AllowSlaac:            dhcpV6AllowSlaacVal,
		DhcpV6Dns:                   dhcpV6DnsVal,
		DhcpV6DnsAuto:               dhcpV6DnsAutoVal,
		DhcpV6Enabled:               dhcpV6EnabledVal,
		DhcpV6LeaseTime:             dhcpV6LeaseTimeVal,
		DhcpV6Start:                 dhcpV6StartVal,
		DhcpV6Stop:                  dhcpV6StopVal,
		DhcpWinsEnabled:             dhcpWinsEnabledVal,
		DhcpWpadUrl:                 dhcpWpadUrlVal,
		DomainName:                  domainNameVal,
		Enabled:                     enabledVal,
		GatewayType:                 gatewayTypeVal,
		Id:                          idVal,
		IgmpSnooping:                igmpSnoopingVal,
		InternetAccessEnabled:       internetAccessEnabledVal,
		Ipv6ClientAddressAssignment: ipv6ClientAddressAssignmentVal,
		Ipv6Enabled:                 ipv6EnabledVal,
		Ipv6InterfaceType:           ipv6InterfaceTypeVal,
		Ipv6PdAutoPrefixidEnabled:   ipv6PdAutoPrefixidEnabledVal,
		Ipv6PdInterface:             ipv6PdInterfaceVal,
		Ipv6PdPrefixid:              ipv6PdPrefixidVal,
		Ipv6PdStart:                 ipv6PdStartVal,
		Ipv6PdStop:                  ipv6PdStopVal,
		Ipv6RaEnabled:               ipv6RaEnabledVal,
		Ipv6RaPreferredLifetime:     ipv6RaPreferredLifetimeVal,
		Ipv6RaPriority:              ipv6RaPriorityVal,
		Ipv6RaValidLifetime:         ipv6RaValidLifetimeVal,
		Ipv6SettingPreference:       ipv6SettingPreferenceVal,
		Ipv6StaticSubnet:            ipv6StaticSubnetVal,
		LteLanEnabled:               lteLanEnabledVal,
		MulticastDnsEnabled:         multicastDnsEnabledVal,
		Name:                        nameVal,
		NatOutboundIpAddresses:      natOutboundIpAddressesVal,
		NetworkGroup:                networkGroupVal,
		NetworkIsolationEnabled:     networkIsolationEnabledVal,
		Purpose:                     purposeVal,
		SettingPreference:           settingPreferenceVal,
		SiteId:                      siteIdVal,
		Subnet:                      subnetVal,
		UpnpLanEnabled:              upnpLanEnabledVal,
		VlanEnabled:                 vlanEnabledVal,
		VlanId:                      vlanIdVal,
		WanDhcpV6PdSize:             wanDhcpV6PdSizeVal,
		WanDns:                      wanDnsVal,
		WanEgressQos:                wanEgressQosVal,
		WanGateway:                  wanGatewayVal,
		WanGatewayV6:                wanGatewayV6Val,
		WanIp:                       wanIpVal,
		WanIpv6:                     wanIpv6Val,
		WanNetmask:                  wanNetmaskVal,
		WanNetworkGroup:             wanNetworkGroupVal,
		WanPassword:                 wanPasswordVal,
		WanPrefixlen:                wanPrefixlenVal,
		WanType:                     wanTypeVal,
		WanTypeV6:                   wanTypeV6Val,
		WanUsername:                 wanUsernameVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	AutoScaleEnabled            basetypes.BoolValue   `tfsdk:"auto_scale_enabled"`
	DhcpBootEnabled             basetypes.BoolValue   `tfsdk:"dhcp_boot_enabled"`
	DhcpBootFilename            basetypes.StringValue `tfsdk:"dhcp_boot_filename"`
	DhcpBootServer              basetypes.StringValue `tfsdk:"dhcp_boot_server"`
	DhcpConflictChecking        basetypes.BoolValue   `tfsdk:"dhcp_conflict_checking"`
	DhcpDns                     basetypes.ListValue   `tfsdk:"dhcp_dns"`
	DhcpDnsEnabled              basetypes.BoolValue   `tfsdk:"dhcp_dns_enabled"`
	DhcpEnabled                 basetypes.BoolValue   `tfsdk:"dhcp_enabled"`
	DhcpGatewayEnabled          basetypes.BoolValue   `tfsdk:"dhcp_gateway_enabled"`
	DhcpGuardEnabled            basetypes.BoolValue   `tfsdk:"dhcp_guard_enabled"`
	DhcpLeaseTime               basetypes.Int64Value  `tfsdk:"dhcp_lease_time"`
	DhcpNtpEnabled              basetypes.BoolValue   `tfsdk:"dhcp_ntp_enabled"`
	DhcpRelayEnabled            basetypes.BoolValue   `tfsdk:"dhcp_relay_enabled"`
	DhcpStart                   basetypes.StringValue `tfsdk:"dhcp_start"`
	DhcpStop                    basetypes.StringValue `tfsdk:"dhcp_stop"`
	DhcpTftpServer              basetypes.StringValue `tfsdk:"dhcp_tftp_server"`
	DhcpTimeOffsetEnabled       basetypes.BoolValue   `tfsdk:"dhcp_time_offset_enabled"`
	DhcpUnifiController         basetypes.StringValue `tfsdk:"dhcp_unifi_controller"`
	DhcpV6AllowSlaac            basetypes.BoolValue   `tfsdk:"dhcp_v6_allow_slaac"`
	DhcpV6Dns                   basetypes.ListValue   `tfsdk:"dhcp_v6_dns"`
	DhcpV6DnsAuto               basetypes.BoolValue   `tfsdk:"dhcp_v6_dns_auto"`
	DhcpV6Enabled               basetypes.BoolValue   `tfsdk:"dhcp_v6_enabled"`
	DhcpV6LeaseTime             basetypes.Int64Value  `tfsdk:"dhcp_v6_lease_time"`
	DhcpV6Start                 basetypes.StringValue `tfsdk:"dhcp_v6_start"`
	DhcpV6Stop                  basetypes.StringValue `tfsdk:"dhcp_v6_stop"`
	DhcpWinsEnabled             basetypes.BoolValue   `tfsdk:"dhcp_wins_enabled"`
	DhcpWpadUrl                 basetypes.StringValue `tfsdk:"dhcp_wpad_url"`
	DomainName                  basetypes.StringValue `tfsdk:"domain_name"`
	Enabled                     basetypes.BoolValue   `tfsdk:"enabled"`
	GatewayType                 basetypes.StringValue `tfsdk:"gateway_type"`
	Id                          basetypes.StringValue `tfsdk:"id"`
	IgmpSnooping                basetypes.BoolValue   `tfsdk:"igmp_snooping"`
	InternetAccessEnabled       basetypes.BoolValue   `tfsdk:"internet_access_enabled"`
	Ipv6ClientAddressAssignment basetypes.StringValue `tfsdk:"ipv6_client_address_assignment"`
	Ipv6Enabled                 basetypes.BoolValue   `tfsdk:"ipv6_enabled"`
	Ipv6InterfaceType           basetypes.StringValue `tfsdk:"ipv6_interface_type"`
	Ipv6PdAutoPrefixidEnabled   basetypes.BoolValue   `tfsdk:"ipv6_pd_auto_prefixid_enabled"`
	Ipv6PdInterface             basetypes.StringValue `tfsdk:"ipv6_pd_interface"`
	Ipv6PdPrefixid              basetypes.StringValue `tfsdk:"ipv6_pd_prefixid"`
	Ipv6PdStart                 basetypes.StringValue `tfsdk:"ipv6_pd_start"`
	Ipv6PdStop                  basetypes.StringValue `tfsdk:"ipv6_pd_stop"`
	Ipv6RaEnabled               basetypes.BoolValue   `tfsdk:"ipv6_ra_enabled"`
	Ipv6RaPreferredLifetime     basetypes.Int64Value  `tfsdk:"ipv6_ra_preferred_lifetime"`
	Ipv6RaPriority              basetypes.StringValue `tfsdk:"ipv6_ra_priority"`
	Ipv6RaValidLifetime         basetypes.Int64Value  `tfsdk:"ipv6_ra_valid_lifetime"`
	Ipv6SettingPreference       basetypes.StringValue `tfsdk:"ipv6_setting_preference"`
	Ipv6StaticSubnet            basetypes.StringValue `tfsdk:"ipv6_static_subnet"`
	LteLanEnabled               basetypes.BoolValue   `tfsdk:"lte_lan_enabled"`
	MulticastDnsEnabled         basetypes.BoolValue   `tfsdk:"multicast_dns_enabled"`
	Name                        basetypes.StringValue `tfsdk:"name"`
	NatOutboundIpAddresses      basetypes.ListValue   `tfsdk:"nat_outbound_ip_addresses"`
	NetworkGroup                basetypes.StringValue `tfsdk:"network_group"`
	NetworkIsolationEnabled     basetypes.BoolValue   `tfsdk:"network_isolation_enabled"`
	Purpose                     basetypes.StringValue `tfsdk:"purpose"`
	SettingPreference           basetypes.StringValue `tfsdk:"setting_preference"`
	SiteId                      basetypes.StringValue `tfsdk:"site_id"`
	Subnet                      basetypes.StringValue `tfsdk:"subnet"`
	UpnpLanEnabled              basetypes.BoolValue   `tfsdk:"upnp_lan_enabled"`
	VlanEnabled                 basetypes.BoolValue   `tfsdk:"vlan_enabled"`
	VlanId                      basetypes.Int64Value  `tfsdk:"vlan_id"`
	WanDhcpV6PdSize             basetypes.Int64Value  `tfsdk:"wan_dhcp_v6_pd_size"`
	WanDns                      basetypes.ListValue   `tfsdk:"wan_dns"`
	WanEgressQos                basetypes.Int64Value  `tfsdk:"wan_egress_qos"`
	WanGateway                  basetypes.StringValue `tfsdk:"wan_gateway"`
	WanGatewayV6                basetypes.StringValue `tfsdk:"wan_gateway_v6"`
	WanIp                       basetypes.StringValue `tfsdk:"wan_ip"`
	WanIpv6                     basetypes.StringValue `tfsdk:"wan_ipv6"`
	WanNetmask                  basetypes.StringValue `tfsdk:"wan_netmask"`
	WanNetworkGroup             basetypes.StringValue `tfsdk:"wan_network_group"`
	WanPassword                 basetypes.StringValue `tfsdk:"wan_password"`
	WanPrefixlen                basetypes.Int64Value  `tfsdk:"wan_prefixlen"`
	WanType                     basetypes.StringValue `tfsdk:"wan_type"`
	WanTypeV6                   basetypes.StringValue `tfsdk:"wan_type_v6"`
	WanUsername                 basetypes.StringValue `tfsdk:"wan_username"`
	state                       attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 74)

	var val tftypes.Value
	var err error

	attrTypes["auto_scale_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_boot_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_boot_filename"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcp_boot_server"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcp_conflict_checking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dhcp_dns_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_gateway_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_guard_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_lease_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dhcp_ntp_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_relay_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_start"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcp_stop"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcp_tftp_server"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcp_time_offset_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_unifi_controller"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcp_v6_allow_slaac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_v6_dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dhcp_v6_dns_auto"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_v6_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_v6_lease_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dhcp_v6_start"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcp_v6_stop"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcp_wins_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp_wpad_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["domain_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["gateway_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["igmp_snooping"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["internet_access_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ipv6_client_address_assignment"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ipv6_interface_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_pd_auto_prefixid_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ipv6_pd_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_pd_prefixid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_pd_start"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_pd_stop"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_ra_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ipv6_ra_preferred_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipv6_ra_priority"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_ra_valid_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipv6_setting_preference"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv6_static_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_lan_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["multicast_dns_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nat_outbound_ip_addresses"] = basetypes.ListType{
		ElemType: NatOutboundIpAddressesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["network_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network_isolation_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["purpose"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["setting_preference"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["site_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["upnp_lan_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wan_dhcp_v6_pd_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wan_dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["wan_egress_qos"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wan_gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_gateway_v6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_ipv6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_network_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_prefixlen"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wan_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_type_v6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 74)

		val, err = v.AutoScaleEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_scale_enabled"] = val

		val, err = v.DhcpBootEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_boot_enabled"] = val

		val, err = v.DhcpBootFilename.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_boot_filename"] = val

		val, err = v.DhcpBootServer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_boot_server"] = val

		val, err = v.DhcpConflictChecking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_conflict_checking"] = val

		val, err = v.DhcpDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_dns"] = val

		val, err = v.DhcpDnsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_dns_enabled"] = val

		val, err = v.DhcpEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_enabled"] = val

		val, err = v.DhcpGatewayEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_gateway_enabled"] = val

		val, err = v.DhcpGuardEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_guard_enabled"] = val

		val, err = v.DhcpLeaseTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_lease_time"] = val

		val, err = v.DhcpNtpEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_ntp_enabled"] = val

		val, err = v.DhcpRelayEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_relay_enabled"] = val

		val, err = v.DhcpStart.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_start"] = val

		val, err = v.DhcpStop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_stop"] = val

		val, err = v.DhcpTftpServer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_tftp_server"] = val

		val, err = v.DhcpTimeOffsetEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_time_offset_enabled"] = val

		val, err = v.DhcpUnifiController.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_unifi_controller"] = val

		val, err = v.DhcpV6AllowSlaac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_v6_allow_slaac"] = val

		val, err = v.DhcpV6Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_v6_dns"] = val

		val, err = v.DhcpV6DnsAuto.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_v6_dns_auto"] = val

		val, err = v.DhcpV6Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_v6_enabled"] = val

		val, err = v.DhcpV6LeaseTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_v6_lease_time"] = val

		val, err = v.DhcpV6Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_v6_start"] = val

		val, err = v.DhcpV6Stop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_v6_stop"] = val

		val, err = v.DhcpWinsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_wins_enabled"] = val

		val, err = v.DhcpWpadUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_wpad_url"] = val

		val, err = v.DomainName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domain_name"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.GatewayType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway_type"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.IgmpSnooping.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["igmp_snooping"] = val

		val, err = v.InternetAccessEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internet_access_enabled"] = val

		val, err = v.Ipv6ClientAddressAssignment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_client_address_assignment"] = val

		val, err = v.Ipv6Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_enabled"] = val

		val, err = v.Ipv6InterfaceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_interface_type"] = val

		val, err = v.Ipv6PdAutoPrefixidEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_pd_auto_prefixid_enabled"] = val

		val, err = v.Ipv6PdInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_pd_interface"] = val

		val, err = v.Ipv6PdPrefixid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_pd_prefixid"] = val

		val, err = v.Ipv6PdStart.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_pd_start"] = val

		val, err = v.Ipv6PdStop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_pd_stop"] = val

		val, err = v.Ipv6RaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_ra_enabled"] = val

		val, err = v.Ipv6RaPreferredLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_ra_preferred_lifetime"] = val

		val, err = v.Ipv6RaPriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_ra_priority"] = val

		val, err = v.Ipv6RaValidLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_ra_valid_lifetime"] = val

		val, err = v.Ipv6SettingPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_setting_preference"] = val

		val, err = v.Ipv6StaticSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_static_subnet"] = val

		val, err = v.LteLanEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_lan_enabled"] = val

		val, err = v.MulticastDnsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multicast_dns_enabled"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NatOutboundIpAddresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_outbound_ip_addresses"] = val

		val, err = v.NetworkGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_group"] = val

		val, err = v.NetworkIsolationEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_isolation_enabled"] = val

		val, err = v.Purpose.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["purpose"] = val

		val, err = v.SettingPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["setting_preference"] = val

		val, err = v.SiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site_id"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.UpnpLanEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["upnp_lan_enabled"] = val

		val, err = v.VlanEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_enabled"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.WanDhcpV6PdSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_dhcp_v6_pd_size"] = val

		val, err = v.WanDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_dns"] = val

		val, err = v.WanEgressQos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_egress_qos"] = val

		val, err = v.WanGateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_gateway"] = val

		val, err = v.WanGatewayV6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_gateway_v6"] = val

		val, err = v.WanIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_ip"] = val

		val, err = v.WanIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_ipv6"] = val

		val, err = v.WanNetmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_netmask"] = val

		val, err = v.WanNetworkGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_network_group"] = val

		val, err = v.WanPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_password"] = val

		val, err = v.WanPrefixlen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_prefixlen"] = val

		val, err = v.WanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_type"] = val

		val, err = v.WanTypeV6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_type_v6"] = val

		val, err = v.WanUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	natOutboundIpAddresses := types.ListValueMust(
		NatOutboundIpAddressesType{
			basetypes.ObjectType{
				AttrTypes: NatOutboundIpAddressesValue{}.AttributeTypes(ctx),
			},
		},
		v.NatOutboundIpAddresses.Elements(),
	)

	if v.NatOutboundIpAddresses.IsNull() {
		natOutboundIpAddresses = types.ListNull(
			NatOutboundIpAddressesType{
				basetypes.ObjectType{
					AttrTypes: NatOutboundIpAddressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NatOutboundIpAddresses.IsUnknown() {
		natOutboundIpAddresses = types.ListUnknown(
			NatOutboundIpAddressesType{
				basetypes.ObjectType{
					AttrTypes: NatOutboundIpAddressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var dhcpDnsVal basetypes.ListValue
	switch {
	case v.DhcpDns.IsUnknown():
		dhcpDnsVal = types.ListUnknown(types.StringType)
	case v.DhcpDns.IsNull():
		dhcpDnsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dhcpDnsVal, d = types.ListValue(types.StringType, v.DhcpDns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_scale_enabled":     basetypes.BoolType{},
			"dhcp_boot_enabled":      basetypes.BoolType{},
			"dhcp_boot_filename":     basetypes.StringType{},
			"dhcp_boot_server":       basetypes.StringType{},
			"dhcp_conflict_checking": basetypes.BoolType{},
			"dhcp_dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dhcp_dns_enabled":         basetypes.BoolType{},
			"dhcp_enabled":             basetypes.BoolType{},
			"dhcp_gateway_enabled":     basetypes.BoolType{},
			"dhcp_guard_enabled":       basetypes.BoolType{},
			"dhcp_lease_time":          basetypes.Int64Type{},
			"dhcp_ntp_enabled":         basetypes.BoolType{},
			"dhcp_relay_enabled":       basetypes.BoolType{},
			"dhcp_start":               basetypes.StringType{},
			"dhcp_stop":                basetypes.StringType{},
			"dhcp_tftp_server":         basetypes.StringType{},
			"dhcp_time_offset_enabled": basetypes.BoolType{},
			"dhcp_unifi_controller":    basetypes.StringType{},
			"dhcp_v6_allow_slaac":      basetypes.BoolType{},
			"dhcp_v6_dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dhcp_v6_dns_auto":               basetypes.BoolType{},
			"dhcp_v6_enabled":                basetypes.BoolType{},
			"dhcp_v6_lease_time":             basetypes.Int64Type{},
			"dhcp_v6_start":                  basetypes.StringType{},
			"dhcp_v6_stop":                   basetypes.StringType{},
			"dhcp_wins_enabled":              basetypes.BoolType{},
			"dhcp_wpad_url":                  basetypes.StringType{},
			"domain_name":                    basetypes.StringType{},
			"enabled":                        basetypes.BoolType{},
			"gateway_type":                   basetypes.StringType{},
			"id":                             basetypes.StringType{},
			"igmp_snooping":                  basetypes.BoolType{},
			"internet_access_enabled":        basetypes.BoolType{},
			"ipv6_client_address_assignment": basetypes.StringType{},
			"ipv6_enabled":                   basetypes.BoolType{},
			"ipv6_interface_type":            basetypes.StringType{},
			"ipv6_pd_auto_prefixid_enabled":  basetypes.BoolType{},
			"ipv6_pd_interface":              basetypes.StringType{},
			"ipv6_pd_prefixid":               basetypes.StringType{},
			"ipv6_pd_start":                  basetypes.StringType{},
			"ipv6_pd_stop":                   basetypes.StringType{},
			"ipv6_ra_enabled":                basetypes.BoolType{},
			"ipv6_ra_preferred_lifetime":     basetypes.Int64Type{},
			"ipv6_ra_priority":               basetypes.StringType{},
			"ipv6_ra_valid_lifetime":         basetypes.Int64Type{},
			"ipv6_setting_preference":        basetypes.StringType{},
			"ipv6_static_subnet":             basetypes.StringType{},
			"lte_lan_enabled":                basetypes.BoolType{},
			"multicast_dns_enabled":          basetypes.BoolType{},
			"name":                           basetypes.StringType{},
			"nat_outbound_ip_addresses": basetypes.ListType{
				ElemType: NatOutboundIpAddressesValue{}.Type(ctx),
			},
			"network_group":             basetypes.StringType{},
			"network_isolation_enabled": basetypes.BoolType{},
			"purpose":                   basetypes.StringType{},
			"setting_preference":        basetypes.StringType{},
			"site_id":                   basetypes.StringType{},
			"subnet":                    basetypes.StringType{},
			"upnp_lan_enabled":          basetypes.BoolType{},
			"vlan_enabled":              basetypes.BoolType{},
			"vlan_id":                   basetypes.Int64Type{},
			"wan_dhcp_v6_pd_size":       basetypes.Int64Type{},
			"wan_dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_egress_qos":    basetypes.Int64Type{},
			"wan_gateway":       basetypes.StringType{},
			"wan_gateway_v6":    basetypes.StringType{},
			"wan_ip":            basetypes.StringType{},
			"wan_ipv6":          basetypes.StringType{},
			"wan_netmask":       basetypes.StringType{},
			"wan_network_group": basetypes.StringType{},
			"wan_password":      basetypes.StringType{},
			"wan_prefixlen":     basetypes.Int64Type{},
			"wan_type":          basetypes.StringType{},
			"wan_type_v6":       basetypes.StringType{},
			"wan_username":      basetypes.StringType{},
		}), diags
	}

	var dhcpV6DnsVal basetypes.ListValue
	switch {
	case v.DhcpV6Dns.IsUnknown():
		dhcpV6DnsVal = types.ListUnknown(types.StringType)
	case v.DhcpV6Dns.IsNull():
		dhcpV6DnsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dhcpV6DnsVal, d = types.ListValue(types.StringType, v.DhcpV6Dns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_scale_enabled":     basetypes.BoolType{},
			"dhcp_boot_enabled":      basetypes.BoolType{},
			"dhcp_boot_filename":     basetypes.StringType{},
			"dhcp_boot_server":       basetypes.StringType{},
			"dhcp_conflict_checking": basetypes.BoolType{},
			"dhcp_dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dhcp_dns_enabled":         basetypes.BoolType{},
			"dhcp_enabled":             basetypes.BoolType{},
			"dhcp_gateway_enabled":     basetypes.BoolType{},
			"dhcp_guard_enabled":       basetypes.BoolType{},
			"dhcp_lease_time":          basetypes.Int64Type{},
			"dhcp_ntp_enabled":         basetypes.BoolType{},
			"dhcp_relay_enabled":       basetypes.BoolType{},
			"dhcp_start":               basetypes.StringType{},
			"dhcp_stop":                basetypes.StringType{},
			"dhcp_tftp_server":         basetypes.StringType{},
			"dhcp_time_offset_enabled": basetypes.BoolType{},
			"dhcp_unifi_controller":    basetypes.StringType{},
			"dhcp_v6_allow_slaac":      basetypes.BoolType{},
			"dhcp_v6_dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dhcp_v6_dns_auto":               basetypes.BoolType{},
			"dhcp_v6_enabled":                basetypes.BoolType{},
			"dhcp_v6_lease_time":             basetypes.Int64Type{},
			"dhcp_v6_start":                  basetypes.StringType{},
			"dhcp_v6_stop":                   basetypes.StringType{},
			"dhcp_wins_enabled":              basetypes.BoolType{},
			"dhcp_wpad_url":                  basetypes.StringType{},
			"domain_name":                    basetypes.StringType{},
			"enabled":                        basetypes.BoolType{},
			"gateway_type":                   basetypes.StringType{},
			"id":                             basetypes.StringType{},
			"igmp_snooping":                  basetypes.BoolType{},
			"internet_access_enabled":        basetypes.BoolType{},
			"ipv6_client_address_assignment": basetypes.StringType{},
			"ipv6_enabled":                   basetypes.BoolType{},
			"ipv6_interface_type":            basetypes.StringType{},
			"ipv6_pd_auto_prefixid_enabled":  basetypes.BoolType{},
			"ipv6_pd_interface":              basetypes.StringType{},
			"ipv6_pd_prefixid":               basetypes.StringType{},
			"ipv6_pd_start":                  basetypes.StringType{},
			"ipv6_pd_stop":                   basetypes.StringType{},
			"ipv6_ra_enabled":                basetypes.BoolType{},
			"ipv6_ra_preferred_lifetime":     basetypes.Int64Type{},
			"ipv6_ra_priority":               basetypes.StringType{},
			"ipv6_ra_valid_lifetime":         basetypes.Int64Type{},
			"ipv6_setting_preference":        basetypes.StringType{},
			"ipv6_static_subnet":             basetypes.StringType{},
			"lte_lan_enabled":                basetypes.BoolType{},
			"multicast_dns_enabled":          basetypes.BoolType{},
			"name":                           basetypes.StringType{},
			"nat_outbound_ip_addresses": basetypes.ListType{
				ElemType: NatOutboundIpAddressesValue{}.Type(ctx),
			},
			"network_group":             basetypes.StringType{},
			"network_isolation_enabled": basetypes.BoolType{},
			"purpose":                   basetypes.StringType{},
			"setting_preference":        basetypes.StringType{},
			"site_id":                   basetypes.StringType{},
			"subnet":                    basetypes.StringType{},
			"upnp_lan_enabled":          basetypes.BoolType{},
			"vlan_enabled":              basetypes.BoolType{},
			"vlan_id":                   basetypes.Int64Type{},
			"wan_dhcp_v6_pd_size":       basetypes.Int64Type{},
			"wan_dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_egress_qos":    basetypes.Int64Type{},
			"wan_gateway":       basetypes.StringType{},
			"wan_gateway_v6":    basetypes.StringType{},
			"wan_ip":            basetypes.StringType{},
			"wan_ipv6":          basetypes.StringType{},
			"wan_netmask":       basetypes.StringType{},
			"wan_network_group": basetypes.StringType{},
			"wan_password":      basetypes.StringType{},
			"wan_prefixlen":     basetypes.Int64Type{},
			"wan_type":          basetypes.StringType{},
			"wan_type_v6":       basetypes.StringType{},
			"wan_username":      basetypes.StringType{},
		}), diags
	}

	var wanDnsVal basetypes.ListValue
	switch {
	case v.WanDns.IsUnknown():
		wanDnsVal = types.ListUnknown(types.StringType)
	case v.WanDns.IsNull():
		wanDnsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		wanDnsVal, d = types.ListValue(types.StringType, v.WanDns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_scale_enabled":     basetypes.BoolType{},
			"dhcp_boot_enabled":      basetypes.BoolType{},
			"dhcp_boot_filename":     basetypes.StringType{},
			"dhcp_boot_server":       basetypes.StringType{},
			"dhcp_conflict_checking": basetypes.BoolType{},
			"dhcp_dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dhcp_dns_enabled":         basetypes.BoolType{},
			"dhcp_enabled":             basetypes.BoolType{},
			"dhcp_gateway_enabled":     basetypes.BoolType{},
			"dhcp_guard_enabled":       basetypes.BoolType{},
			"dhcp_lease_time":          basetypes.Int64Type{},
			"dhcp_ntp_enabled":         basetypes.BoolType{},
			"dhcp_relay_enabled":       basetypes.BoolType{},
			"dhcp_start":               basetypes.StringType{},
			"dhcp_stop":                basetypes.StringType{},
			"dhcp_tftp_server":         basetypes.StringType{},
			"dhcp_time_offset_enabled": basetypes.BoolType{},
			"dhcp_unifi_controller":    basetypes.StringType{},
			"dhcp_v6_allow_slaac":      basetypes.BoolType{},
			"dhcp_v6_dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dhcp_v6_dns_auto":               basetypes.BoolType{},
			"dhcp_v6_enabled":                basetypes.BoolType{},
			"dhcp_v6_lease_time":             basetypes.Int64Type{},
			"dhcp_v6_start":                  basetypes.StringType{},
			"dhcp_v6_stop":                   basetypes.StringType{},
			"dhcp_wins_enabled":              basetypes.BoolType{},
			"dhcp_wpad_url":                  basetypes.StringType{},
			"domain_name":                    basetypes.StringType{},
			"enabled":                        basetypes.BoolType{},
			"gateway_type":                   basetypes.StringType{},
			"id":                             basetypes.StringType{},
			"igmp_snooping":                  basetypes.BoolType{},
			"internet_access_enabled":        basetypes.BoolType{},
			"ipv6_client_address_assignment": basetypes.StringType{},
			"ipv6_enabled":                   basetypes.BoolType{},
			"ipv6_interface_type":            basetypes.StringType{},
			"ipv6_pd_auto_prefixid_enabled":  basetypes.BoolType{},
			"ipv6_pd_interface":              basetypes.StringType{},
			"ipv6_pd_prefixid":               basetypes.StringType{},
			"ipv6_pd_start":                  basetypes.StringType{},
			"ipv6_pd_stop":                   basetypes.StringType{},
			"ipv6_ra_enabled":                basetypes.BoolType{},
			"ipv6_ra_preferred_lifetime":     basetypes.Int64Type{},
			"ipv6_ra_priority":               basetypes.StringType{},
			"ipv6_ra_valid_lifetime":         basetypes.Int64Type{},
			"ipv6_setting_preference":        basetypes.StringType{},
			"ipv6_static_subnet":             basetypes.StringType{},
			"lte_lan_enabled":                basetypes.BoolType{},
			"multicast_dns_enabled":          basetypes.BoolType{},
			"name":                           basetypes.StringType{},
			"nat_outbound_ip_addresses": basetypes.ListType{
				ElemType: NatOutboundIpAddressesValue{}.Type(ctx),
			},
			"network_group":             basetypes.StringType{},
			"network_isolation_enabled": basetypes.BoolType{},
			"purpose":                   basetypes.StringType{},
			"setting_preference":        basetypes.StringType{},
			"site_id":                   basetypes.StringType{},
			"subnet":                    basetypes.StringType{},
			"upnp_lan_enabled":          basetypes.BoolType{},
			"vlan_enabled":              basetypes.BoolType{},
			"vlan_id":                   basetypes.Int64Type{},
			"wan_dhcp_v6_pd_size":       basetypes.Int64Type{},
			"wan_dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_egress_qos":    basetypes.Int64Type{},
			"wan_gateway":       basetypes.StringType{},
			"wan_gateway_v6":    basetypes.StringType{},
			"wan_ip":            basetypes.StringType{},
			"wan_ipv6":          basetypes.StringType{},
			"wan_netmask":       basetypes.StringType{},
			"wan_network_group": basetypes.StringType{},
			"wan_password":      basetypes.StringType{},
			"wan_prefixlen":     basetypes.Int64Type{},
			"wan_type":          basetypes.StringType{},
			"wan_type_v6":       basetypes.StringType{},
			"wan_username":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auto_scale_enabled":     basetypes.BoolType{},
		"dhcp_boot_enabled":      basetypes.BoolType{},
		"dhcp_boot_filename":     basetypes.StringType{},
		"dhcp_boot_server":       basetypes.StringType{},
		"dhcp_conflict_checking": basetypes.BoolType{},
		"dhcp_dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dhcp_dns_enabled":         basetypes.BoolType{},
		"dhcp_enabled":             basetypes.BoolType{},
		"dhcp_gateway_enabled":     basetypes.BoolType{},
		"dhcp_guard_enabled":       basetypes.BoolType{},
		"dhcp_lease_time":          basetypes.Int64Type{},
		"dhcp_ntp_enabled":         basetypes.BoolType{},
		"dhcp_relay_enabled":       basetypes.BoolType{},
		"dhcp_start":               basetypes.StringType{},
		"dhcp_stop":                basetypes.StringType{},
		"dhcp_tftp_server":         basetypes.StringType{},
		"dhcp_time_offset_enabled": basetypes.BoolType{},
		"dhcp_unifi_controller":    basetypes.StringType{},
		"dhcp_v6_allow_slaac":      basetypes.BoolType{},
		"dhcp_v6_dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dhcp_v6_dns_auto":               basetypes.BoolType{},
		"dhcp_v6_enabled":                basetypes.BoolType{},
		"dhcp_v6_lease_time":             basetypes.Int64Type{},
		"dhcp_v6_start":                  basetypes.StringType{},
		"dhcp_v6_stop":                   basetypes.StringType{},
		"dhcp_wins_enabled":              basetypes.BoolType{},
		"dhcp_wpad_url":                  basetypes.StringType{},
		"domain_name":                    basetypes.StringType{},
		"enabled":                        basetypes.BoolType{},
		"gateway_type":                   basetypes.StringType{},
		"id":                             basetypes.StringType{},
		"igmp_snooping":                  basetypes.BoolType{},
		"internet_access_enabled":        basetypes.BoolType{},
		"ipv6_client_address_assignment": basetypes.StringType{},
		"ipv6_enabled":                   basetypes.BoolType{},
		"ipv6_interface_type":            basetypes.StringType{},
		"ipv6_pd_auto_prefixid_enabled":  basetypes.BoolType{},
		"ipv6_pd_interface":              basetypes.StringType{},
		"ipv6_pd_prefixid":               basetypes.StringType{},
		"ipv6_pd_start":                  basetypes.StringType{},
		"ipv6_pd_stop":                   basetypes.StringType{},
		"ipv6_ra_enabled":                basetypes.BoolType{},
		"ipv6_ra_preferred_lifetime":     basetypes.Int64Type{},
		"ipv6_ra_priority":               basetypes.StringType{},
		"ipv6_ra_valid_lifetime":         basetypes.Int64Type{},
		"ipv6_setting_preference":        basetypes.StringType{},
		"ipv6_static_subnet":             basetypes.StringType{},
		"lte_lan_enabled":                basetypes.BoolType{},
		"multicast_dns_enabled":          basetypes.BoolType{},
		"name":                           basetypes.StringType{},
		"nat_outbound_ip_addresses": basetypes.ListType{
			ElemType: NatOutboundIpAddressesValue{}.Type(ctx),
		},
		"network_group":             basetypes.StringType{},
		"network_isolation_enabled": basetypes.BoolType{},
		"purpose":                   basetypes.StringType{},
		"setting_preference":        basetypes.StringType{},
		"site_id":                   basetypes.StringType{},
		"subnet":                    basetypes.StringType{},
		"upnp_lan_enabled":          basetypes.BoolType{},
		"vlan_enabled":              basetypes.BoolType{},
		"vlan_id":                   basetypes.Int64Type{},
		"wan_dhcp_v6_pd_size":       basetypes.Int64Type{},
		"wan_dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_egress_qos":    basetypes.Int64Type{},
		"wan_gateway":       basetypes.StringType{},
		"wan_gateway_v6":    basetypes.StringType{},
		"wan_ip":            basetypes.StringType{},
		"wan_ipv6":          basetypes.StringType{},
		"wan_netmask":       basetypes.StringType{},
		"wan_network_group": basetypes.StringType{},
		"wan_password":      basetypes.StringType{},
		"wan_prefixlen":     basetypes.Int64Type{},
		"wan_type":          basetypes.StringType{},
		"wan_type_v6":       basetypes.StringType{},
		"wan_username":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_scale_enabled":             v.AutoScaleEnabled,
			"dhcp_boot_enabled":              v.DhcpBootEnabled,
			"dhcp_boot_filename":             v.DhcpBootFilename,
			"dhcp_boot_server":               v.DhcpBootServer,
			"dhcp_conflict_checking":         v.DhcpConflictChecking,
			"dhcp_dns":                       dhcpDnsVal,
			"dhcp_dns_enabled":               v.DhcpDnsEnabled,
			"dhcp_enabled":                   v.DhcpEnabled,
			"dhcp_gateway_enabled":           v.DhcpGatewayEnabled,
			"dhcp_guard_enabled":             v.DhcpGuardEnabled,
			"dhcp_lease_time":                v.DhcpLeaseTime,
			"dhcp_ntp_enabled":               v.DhcpNtpEnabled,
			"dhcp_relay_enabled":             v.DhcpRelayEnabled,
			"dhcp_start":                     v.DhcpStart,
			"dhcp_stop":                      v.DhcpStop,
			"dhcp_tftp_server":               v.DhcpTftpServer,
			"dhcp_time_offset_enabled":       v.DhcpTimeOffsetEnabled,
			"dhcp_unifi_controller":          v.DhcpUnifiController,
			"dhcp_v6_allow_slaac":            v.DhcpV6AllowSlaac,
			"dhcp_v6_dns":                    dhcpV6DnsVal,
			"dhcp_v6_dns_auto":               v.DhcpV6DnsAuto,
			"dhcp_v6_enabled":                v.DhcpV6Enabled,
			"dhcp_v6_lease_time":             v.DhcpV6LeaseTime,
			"dhcp_v6_start":                  v.DhcpV6Start,
			"dhcp_v6_stop":                   v.DhcpV6Stop,
			"dhcp_wins_enabled":              v.DhcpWinsEnabled,
			"dhcp_wpad_url":                  v.DhcpWpadUrl,
			"domain_name":                    v.DomainName,
			"enabled":                        v.Enabled,
			"gateway_type":                   v.GatewayType,
			"id":                             v.Id,
			"igmp_snooping":                  v.IgmpSnooping,
			"internet_access_enabled":        v.InternetAccessEnabled,
			"ipv6_client_address_assignment": v.Ipv6ClientAddressAssignment,
			"ipv6_enabled":                   v.Ipv6Enabled,
			"ipv6_interface_type":            v.Ipv6InterfaceType,
			"ipv6_pd_auto_prefixid_enabled":  v.Ipv6PdAutoPrefixidEnabled,
			"ipv6_pd_interface":              v.Ipv6PdInterface,
			"ipv6_pd_prefixid":               v.Ipv6PdPrefixid,
			"ipv6_pd_start":                  v.Ipv6PdStart,
			"ipv6_pd_stop":                   v.Ipv6PdStop,
			"ipv6_ra_enabled":                v.Ipv6RaEnabled,
			"ipv6_ra_preferred_lifetime":     v.Ipv6RaPreferredLifetime,
			"ipv6_ra_priority":               v.Ipv6RaPriority,
			"ipv6_ra_valid_lifetime":         v.Ipv6RaValidLifetime,
			"ipv6_setting_preference":        v.Ipv6SettingPreference,
			"ipv6_static_subnet":             v.Ipv6StaticSubnet,
			"lte_lan_enabled":                v.LteLanEnabled,
			"multicast_dns_enabled":          v.MulticastDnsEnabled,
			"name":                           v.Name,
			"nat_outbound_ip_addresses":      natOutboundIpAddresses,
			"network_group":                  v.NetworkGroup,
			"network_isolation_enabled":      v.NetworkIsolationEnabled,
			"purpose":                        v.Purpose,
			"setting_preference":             v.SettingPreference,
			"site_id":                        v.SiteId,
			"subnet":                         v.Subnet,
			"upnp_lan_enabled":               v.UpnpLanEnabled,
			"vlan_enabled":                   v.VlanEnabled,
			"vlan_id":                        v.VlanId,
			"wan_dhcp_v6_pd_size":            v.WanDhcpV6PdSize,
			"wan_dns":                        wanDnsVal,
			"wan_egress_qos":                 v.WanEgressQos,
			"wan_gateway":                    v.WanGateway,
			"wan_gateway_v6":                 v.WanGatewayV6,
			"wan_ip":                         v.WanIp,
			"wan_ipv6":                       v.WanIpv6,
			"wan_netmask":                    v.WanNetmask,
			"wan_network_group":              v.WanNetworkGroup,
			"wan_password":                   v.WanPassword,
			"wan_prefixlen":                  v.WanPrefixlen,
			"wan_type":                       v.WanType,
			"wan_type_v6":                    v.WanTypeV6,
			"wan_username":                   v.WanUsername,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoScaleEnabled.Equal(other.AutoScaleEnabled) {
		return false
	}

	if !v.DhcpBootEnabled.Equal(other.DhcpBootEnabled) {
		return false
	}

	if !v.DhcpBootFilename.Equal(other.DhcpBootFilename) {
		return false
	}

	if !v.DhcpBootServer.Equal(other.DhcpBootServer) {
		return false
	}

	if !v.DhcpConflictChecking.Equal(other.DhcpConflictChecking) {
		return false
	}

	if !v.DhcpDns.Equal(other.DhcpDns) {
		return false
	}

	if !v.DhcpDnsEnabled.Equal(other.DhcpDnsEnabled) {
		return false
	}

	if !v.DhcpEnabled.Equal(other.DhcpEnabled) {
		return false
	}

	if !v.DhcpGatewayEnabled.Equal(other.DhcpGatewayEnabled) {
		return false
	}

	if !v.DhcpGuardEnabled.Equal(other.DhcpGuardEnabled) {
		return false
	}

	if !v.DhcpLeaseTime.Equal(other.DhcpLeaseTime) {
		return false
	}

	if !v.DhcpNtpEnabled.Equal(other.DhcpNtpEnabled) {
		return false
	}

	if !v.DhcpRelayEnabled.Equal(other.DhcpRelayEnabled) {
		return false
	}

	if !v.DhcpStart.Equal(other.DhcpStart) {
		return false
	}

	if !v.DhcpStop.Equal(other.DhcpStop) {
		return false
	}

	if !v.DhcpTftpServer.Equal(other.DhcpTftpServer) {
		return false
	}

	if !v.DhcpTimeOffsetEnabled.Equal(other.DhcpTimeOffsetEnabled) {
		return false
	}

	if !v.DhcpUnifiController.Equal(other.DhcpUnifiController) {
		return false
	}

	if !v.DhcpV6AllowSlaac.Equal(other.DhcpV6AllowSlaac) {
		return false
	}

	if !v.DhcpV6Dns.Equal(other.DhcpV6Dns) {
		return false
	}

	if !v.DhcpV6DnsAuto.Equal(other.DhcpV6DnsAuto) {
		return false
	}

	if !v.DhcpV6Enabled.Equal(other.DhcpV6Enabled) {
		return false
	}

	if !v.DhcpV6LeaseTime.Equal(other.DhcpV6LeaseTime) {
		return false
	}

	if !v.DhcpV6Start.Equal(other.DhcpV6Start) {
		return false
	}

	if !v.DhcpV6Stop.Equal(other.DhcpV6Stop) {
		return false
	}

	if !v.DhcpWinsEnabled.Equal(other.DhcpWinsEnabled) {
		return false
	}

	if !v.DhcpWpadUrl.Equal(other.DhcpWpadUrl) {
		return false
	}

	if !v.DomainName.Equal(other.DomainName) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.GatewayType.Equal(other.GatewayType) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.IgmpSnooping.Equal(other.IgmpSnooping) {
		return false
	}

	if !v.InternetAccessEnabled.Equal(other.InternetAccessEnabled) {
		return false
	}

	if !v.Ipv6ClientAddressAssignment.Equal(other.Ipv6ClientAddressAssignment) {
		return false
	}

	if !v.Ipv6Enabled.Equal(other.Ipv6Enabled) {
		return false
	}

	if !v.Ipv6InterfaceType.Equal(other.Ipv6InterfaceType) {
		return false
	}

	if !v.Ipv6PdAutoPrefixidEnabled.Equal(other.Ipv6PdAutoPrefixidEnabled) {
		return false
	}

	if !v.Ipv6PdInterface.Equal(other.Ipv6PdInterface) {
		return false
	}

	if !v.Ipv6PdPrefixid.Equal(other.Ipv6PdPrefixid) {
		return false
	}

	if !v.Ipv6PdStart.Equal(other.Ipv6PdStart) {
		return false
	}

	if !v.Ipv6PdStop.Equal(other.Ipv6PdStop) {
		return false
	}

	if !v.Ipv6RaEnabled.Equal(other.Ipv6RaEnabled) {
		return false
	}

	if !v.Ipv6RaPreferredLifetime.Equal(other.Ipv6RaPreferredLifetime) {
		return false
	}

	if !v.Ipv6RaPriority.Equal(other.Ipv6RaPriority) {
		return false
	}

	if !v.Ipv6RaValidLifetime.Equal(other.Ipv6RaValidLifetime) {
		return false
	}

	if !v.Ipv6SettingPreference.Equal(other.Ipv6SettingPreference) {
		return false
	}

	if !v.Ipv6StaticSubnet.Equal(other.Ipv6StaticSubnet) {
		return false
	}

	if !v.LteLanEnabled.Equal(other.LteLanEnabled) {
		return false
	}

	if !v.MulticastDnsEnabled.Equal(other.MulticastDnsEnabled) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NatOutboundIpAddresses.Equal(other.NatOutboundIpAddresses) {
		return false
	}

	if !v.NetworkGroup.Equal(other.NetworkGroup) {
		return false
	}

	if !v.NetworkIsolationEnabled.Equal(other.NetworkIsolationEnabled) {
		return false
	}

	if !v.Purpose.Equal(other.Purpose) {
		return false
	}

	if !v.SettingPreference.Equal(other.SettingPreference) {
		return false
	}

	if !v.SiteId.Equal(other.SiteId) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.UpnpLanEnabled.Equal(other.UpnpLanEnabled) {
		return false
	}

	if !v.VlanEnabled.Equal(other.VlanEnabled) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.WanDhcpV6PdSize.Equal(other.WanDhcpV6PdSize) {
		return false
	}

	if !v.WanDns.Equal(other.WanDns) {
		return false
	}

	if !v.WanEgressQos.Equal(other.WanEgressQos) {
		return false
	}

	if !v.WanGateway.Equal(other.WanGateway) {
		return false
	}

	if !v.WanGatewayV6.Equal(other.WanGatewayV6) {
		return false
	}

	if !v.WanIp.Equal(other.WanIp) {
		return false
	}

	if !v.WanIpv6.Equal(other.WanIpv6) {
		return false
	}

	if !v.WanNetmask.Equal(other.WanNetmask) {
		return false
	}

	if !v.WanNetworkGroup.Equal(other.WanNetworkGroup) {
		return false
	}

	if !v.WanPassword.Equal(other.WanPassword) {
		return false
	}

	if !v.WanPrefixlen.Equal(other.WanPrefixlen) {
		return false
	}

	if !v.WanType.Equal(other.WanType) {
		return false
	}

	if !v.WanTypeV6.Equal(other.WanTypeV6) {
		return false
	}

	if !v.WanUsername.Equal(other.WanUsername) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_scale_enabled":     basetypes.BoolType{},
		"dhcp_boot_enabled":      basetypes.BoolType{},
		"dhcp_boot_filename":     basetypes.StringType{},
		"dhcp_boot_server":       basetypes.StringType{},
		"dhcp_conflict_checking": basetypes.BoolType{},
		"dhcp_dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dhcp_dns_enabled":         basetypes.BoolType{},
		"dhcp_enabled":             basetypes.BoolType{},
		"dhcp_gateway_enabled":     basetypes.BoolType{},
		"dhcp_guard_enabled":       basetypes.BoolType{},
		"dhcp_lease_time":          basetypes.Int64Type{},
		"dhcp_ntp_enabled":         basetypes.BoolType{},
		"dhcp_relay_enabled":       basetypes.BoolType{},
		"dhcp_start":               basetypes.StringType{},
		"dhcp_stop":                basetypes.StringType{},
		"dhcp_tftp_server":         basetypes.StringType{},
		"dhcp_time_offset_enabled": basetypes.BoolType{},
		"dhcp_unifi_controller":    basetypes.StringType{},
		"dhcp_v6_allow_slaac":      basetypes.BoolType{},
		"dhcp_v6_dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dhcp_v6_dns_auto":               basetypes.BoolType{},
		"dhcp_v6_enabled":                basetypes.BoolType{},
		"dhcp_v6_lease_time":             basetypes.Int64Type{},
		"dhcp_v6_start":                  basetypes.StringType{},
		"dhcp_v6_stop":                   basetypes.StringType{},
		"dhcp_wins_enabled":              basetypes.BoolType{},
		"dhcp_wpad_url":                  basetypes.StringType{},
		"domain_name":                    basetypes.StringType{},
		"enabled":                        basetypes.BoolType{},
		"gateway_type":                   basetypes.StringType{},
		"id":                             basetypes.StringType{},
		"igmp_snooping":                  basetypes.BoolType{},
		"internet_access_enabled":        basetypes.BoolType{},
		"ipv6_client_address_assignment": basetypes.StringType{},
		"ipv6_enabled":                   basetypes.BoolType{},
		"ipv6_interface_type":            basetypes.StringType{},
		"ipv6_pd_auto_prefixid_enabled":  basetypes.BoolType{},
		"ipv6_pd_interface":              basetypes.StringType{},
		"ipv6_pd_prefixid":               basetypes.StringType{},
		"ipv6_pd_start":                  basetypes.StringType{},
		"ipv6_pd_stop":                   basetypes.StringType{},
		"ipv6_ra_enabled":                basetypes.BoolType{},
		"ipv6_ra_preferred_lifetime":     basetypes.Int64Type{},
		"ipv6_ra_priority":               basetypes.StringType{},
		"ipv6_ra_valid_lifetime":         basetypes.Int64Type{},
		"ipv6_setting_preference":        basetypes.StringType{},
		"ipv6_static_subnet":             basetypes.StringType{},
		"lte_lan_enabled":                basetypes.BoolType{},
		"multicast_dns_enabled":          basetypes.BoolType{},
		"name":                           basetypes.StringType{},
		"nat_outbound_ip_addresses": basetypes.ListType{
			ElemType: NatOutboundIpAddressesValue{}.Type(ctx),
		},
		"network_group":             basetypes.StringType{},
		"network_isolation_enabled": basetypes.BoolType{},
		"purpose":                   basetypes.StringType{},
		"setting_preference":        basetypes.StringType{},
		"site_id":                   basetypes.StringType{},
		"subnet":                    basetypes.StringType{},
		"upnp_lan_enabled":          basetypes.BoolType{},
		"vlan_enabled":              basetypes.BoolType{},
		"vlan_id":                   basetypes.Int64Type{},
		"wan_dhcp_v6_pd_size":       basetypes.Int64Type{},
		"wan_dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_egress_qos":    basetypes.Int64Type{},
		"wan_gateway":       basetypes.StringType{},
		"wan_gateway_v6":    basetypes.StringType{},
		"wan_ip":            basetypes.StringType{},
		"wan_ipv6":          basetypes.StringType{},
		"wan_netmask":       basetypes.StringType{},
		"wan_network_group": basetypes.StringType{},
		"wan_password":      basetypes.StringType{},
		"wan_prefixlen":     basetypes.Int64Type{},
		"wan_type":          basetypes.StringType{},
		"wan_type_v6":       basetypes.StringType{},
		"wan_username":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NatOutboundIpAddressesType{}

type NatOutboundIpAddressesType struct {
	basetypes.ObjectType
}

func (t NatOutboundIpAddressesType) Equal(o attr.Type) bool {
	other, ok := o.(NatOutboundIpAddressesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NatOutboundIpAddressesType) String() string {
	return "NatOutboundIpAddressesType"
}

func (t NatOutboundIpAddressesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	ipAddressPoolAttribute, ok := attributes["ip_address_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address_pool is missing from object`)

		return nil, diags
	}

	ipAddressPoolVal, ok := ipAddressPoolAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address_pool expected to be basetypes.ListValue, was: %T`, ipAddressPoolAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	wanNetworkGroupAttribute, ok := attributes["wan_network_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_network_group is missing from object`)

		return nil, diags
	}

	wanNetworkGroupVal, ok := wanNetworkGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_network_group expected to be basetypes.StringValue, was: %T`, wanNetworkGroupAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NatOutboundIpAddressesValue{
		IpAddress:       ipAddressVal,
		IpAddressPool:   ipAddressPoolVal,
		Mode:            modeVal,
		WanNetworkGroup: wanNetworkGroupVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewNatOutboundIpAddressesValueNull() NatOutboundIpAddressesValue {
	return NatOutboundIpAddressesValue{
		state: attr.ValueStateNull,
	}
}

func NewNatOutboundIpAddressesValueUnknown() NatOutboundIpAddressesValue {
	return NatOutboundIpAddressesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNatOutboundIpAddressesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NatOutboundIpAddressesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NatOutboundIpAddressesValue Attribute Value",
				"While creating a NatOutboundIpAddressesValue value, a missing attribute value was detected. "+
					"A NatOutboundIpAddressesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NatOutboundIpAddressesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NatOutboundIpAddressesValue Attribute Type",
				"While creating a NatOutboundIpAddressesValue value, an invalid attribute value was detected. "+
					"A NatOutboundIpAddressesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NatOutboundIpAddressesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NatOutboundIpAddressesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NatOutboundIpAddressesValue Attribute Value",
				"While creating a NatOutboundIpAddressesValue value, an extra attribute value was detected. "+
					"A NatOutboundIpAddressesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NatOutboundIpAddressesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNatOutboundIpAddressesValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewNatOutboundIpAddressesValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	ipAddressPoolAttribute, ok := attributes["ip_address_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address_pool is missing from object`)

		return NewNatOutboundIpAddressesValueUnknown(), diags
	}

	ipAddressPoolVal, ok := ipAddressPoolAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address_pool expected to be basetypes.ListValue, was: %T`, ipAddressPoolAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewNatOutboundIpAddressesValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	wanNetworkGroupAttribute, ok := attributes["wan_network_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_network_group is missing from object`)

		return NewNatOutboundIpAddressesValueUnknown(), diags
	}

	wanNetworkGroupVal, ok := wanNetworkGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_network_group expected to be basetypes.StringValue, was: %T`, wanNetworkGroupAttribute))
	}

	if diags.HasError() {
		return NewNatOutboundIpAddressesValueUnknown(), diags
	}

	return NatOutboundIpAddressesValue{
		IpAddress:       ipAddressVal,
		IpAddressPool:   ipAddressPoolVal,
		Mode:            modeVal,
		WanNetworkGroup: wanNetworkGroupVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewNatOutboundIpAddressesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NatOutboundIpAddressesValue {
	object, diags := NewNatOutboundIpAddressesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNatOutboundIpAddressesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NatOutboundIpAddressesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNatOutboundIpAddressesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNatOutboundIpAddressesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNatOutboundIpAddressesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNatOutboundIpAddressesValueMust(NatOutboundIpAddressesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NatOutboundIpAddressesType) ValueType(ctx context.Context) attr.Value {
	return NatOutboundIpAddressesValue{}
}

var _ basetypes.ObjectValuable = NatOutboundIpAddressesValue{}

type NatOutboundIpAddressesValue struct {
	IpAddress       basetypes.StringValue `tfsdk:"ip_address"`
	IpAddressPool   basetypes.ListValue   `tfsdk:"ip_address_pool"`
	Mode            basetypes.StringValue `tfsdk:"mode"`
	WanNetworkGroup basetypes.StringValue `tfsdk:"wan_network_group"`
	state           attr.ValueState
}

func (v NatOutboundIpAddressesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_address_pool"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_network_group"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.IpAddressPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address_pool"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.WanNetworkGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_network_group"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NatOutboundIpAddressesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NatOutboundIpAddressesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NatOutboundIpAddressesValue) String() string {
	return "NatOutboundIpAddressesValue"
}

func (v NatOutboundIpAddressesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ipAddressPoolVal basetypes.ListValue
	switch {
	case v.IpAddressPool.IsUnknown():
		ipAddressPoolVal = types.ListUnknown(types.StringType)
	case v.IpAddressPool.IsNull():
		ipAddressPoolVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		ipAddressPoolVal, d = types.ListValue(types.StringType, v.IpAddressPool.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ip_address": basetypes.StringType{},
			"ip_address_pool": basetypes.ListType{
				ElemType: types.StringType,
			},
			"mode":              basetypes.StringType{},
			"wan_network_group": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"ip_address_pool": basetypes.ListType{
			ElemType: types.StringType,
		},
		"mode":              basetypes.StringType{},
		"wan_network_group": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address":        v.IpAddress,
			"ip_address_pool":   ipAddressPoolVal,
			"mode":              v.Mode,
			"wan_network_group": v.WanNetworkGroup,
		})

	return objVal, diags
}

func (v NatOutboundIpAddressesValue) Equal(o attr.Value) bool {
	other, ok := o.(NatOutboundIpAddressesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.IpAddressPool.Equal(other.IpAddressPool) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.WanNetworkGroup.Equal(other.WanNetworkGroup) {
		return false
	}

	return true
}

func (v NatOutboundIpAddressesValue) Type(ctx context.Context) attr.Type {
	return NatOutboundIpAddressesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NatOutboundIpAddressesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"ip_address_pool": basetypes.ListType{
			ElemType: types.StringType,
		},
		"mode":              basetypes.StringType{},
		"wan_network_group": basetypes.StringType{},
	}
}
